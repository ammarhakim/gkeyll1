A common use of arrays in Lucee is to store vector fields. For example,
to store the electric field in a 2D simulation one would create a 3D
array (the final index for the components of the electric field):
@example
unsigned shape[3] = @{16, 32, 3@};
Lucee::Array<3, double> E(shape);
@end example

@noindent
Although this array can be indexed in the usual way, it is ofter more
convenient to get access to all three components:
@example
Lucee::ArrayItr<double> ef = E.createItr();
E.setItr(ef, 3, 4);
ef[0] = 1.0; ef[1] = 2.0; ef[2] = 1.0;
@end example

@noindent
The iterator @code{ef} points to the three elements of the electric
field at location @math{(3,4)}. This code is equivalent to
@example
E(3, 4, 0) = 1.0;
E(3, 4, 1) = 2.0;
E(3, 4, 2) = 1.0;
@end example

@noindent
The advantage of using the iterator to access the components is that the
iterator can be passed to other functions which expect @code{double *}:
@example
double norm = computeNorm(&ef[0]);
@end example
where, for example,
@example
double computeNorm(double *vec) 
@{
  return sqrt(vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2]);
@}
@end example

By default arrays are zero-based but other start indices can also be
specified. Arrays can be created by specifying the shape and,
optionally, the starting index along each rank.
@example
#include <LcArray.h>

unsigned shape[2] = @{5, 10@};
Lucee::Array<2, double> arr1(shape);

int start[2] = @{2, 0@};
Lucee::Array<2, double> arr2(shape, start);
@end example

@noindent
This will create rank-two @math{5\times 10} arrays @code{arr1}, indexed
starting @math{(0,0)}, and @code{arr2}, indexed starting
@math{(2,0)}. All elements in the array can be set using the assignment
operator: for example, @code{arr1=5.0}, will set all elements of
@code{arr1} to @math{5.0}. One can loop over the arrays, setting them:
@example
for (int i=arr1.getLower(0); i<arr1.getUpper(0); ++i)
  for (int j=arr1.getLower(1); j<arr1.getUpper(1); ++j)
    arr1(i,j) = i+j;
@end example

View-arrays into an existing array can be created. View-arrays are
arrays that allow access to parts of another array. Modifications made
to the original or view-array are reflected in the other,
i.e. view-arrays share data with their parent array.
@example
unsigned shape[2] = @{100, 100@};
Lucee::Array<2, double> arr(shape);

unsigned viewShape[2] = @{20, 20@};
int viewStart[2] = @{5, 5@};
int zeros[2] = @{0, 0@};
Lucee::Array<2, double>& view =
  arr.createView(viewShape, viewStart, zeros);
@end example

@noindent
This will create a view-array @code{view} into the original array
@code{arr}. The view-array's start index will be @math{(0,0)}.
Modifications made to either the view-array or the original array will
also affect the other.

Sometimes a view-array of a lower dimension than the original one needs
to be created. For example, say an array representing row @math{3} of
@code{arr} is required. This can be done as follows:
@example
unsigned deflateRanks[1] = @{0@};
int deflateIdx[1] = @{3@};
unsigned viewShape[1] = arr.shape(1);
int viewStart[1];
viewStart[0] = arr.lower(1);

Lucee::Array<1, double>& row3 =
  arr.createView<1>(deflateRanks, deflateIdx, viewShape, viewStart);
@end example
This will create @code{row3} be an alias for row @math{3} in
@code{arr}.
