# -*- org -*-

* December 27th

** Lucee cleanup

  Need to remove or rething the GridGeometry class. There is
  significant confusion by the hard coded names ("cell", "face",
  "edge") and this needs to be rethought.

  CmdLineArgs can be replaced with Boost. [No need: Cmd line usage is
  minor in lucee]

  Should Except class be replaced?

  Should the custom Lucee loggers be eliminated? One could think of
  using http://www.pantheios.org/. However, it appears to be not worth
  the time for now.

  Should we replace LcTest.h with Boost unit testing framework?

  Fix all doxygen errors.

* December 18th

** On doing things correctly

   In the next 3 or 4 years I want to create my own comprehensive
   plasma simulation system for tokamaks and other fusion devices. The
   organised efforts in this area are too restrictive and conservative
   and do not have the courage to throw out the old and adopt modern
   standards based software systems. It is time that an individual or
   a small group takes on this task in parallel with the current large
   efforts and attempts a radically different and innovative
   solution. Components like FMCFM can be used. However, any component
   that does not meet software quality standards will be rejected and
   rewritten.

   Failure is highly likely but success can have major payoff.

   A part of this project will be to develop a class on "Software
   Design for Computational Physics". This should teach good software
   practices keeping in mind special requirements for computational
   physics. Standards (XML, XSD, SQL, C++, etc etc) should be used
   with the understanding that these change over a period of time
   which should be thought out early in a project.

   A clean seperation of software components should be made based on
   careful analysis of the specific problem. The analysis of grids is
   a good but complex example of this. Other simpler examples (finite
   difference, finite volume and finite element schemes) should be
   worked out also. The emphasis in this part should be the careful
   seperation of code based on the underlying mathematical structures
   and not ease of implementation in a particular language.

   Other examples: discrete exterior calculus, Newton-Krylov-Schwarz
   schemes and Riemann solver based schemes for hyperbolic equations.

   Bourbaki of computational plasma physics.

* December 15th

  Removed the HDF5 from Lucee and instead now using the implementation
  from txbase. 

  Next step is to remove the unstructured grids from Lucee to avoid
  any issues with Nautilus.
  
  Loki replacement by Boost can wait. For now it is more important to
  look at the Boost library and see it can be used for anything in
  Lucee. It has some good stuff that might be useful.

  More important is to get the fields working with MPI. With this
  Lucee will be parallel and ready for prime-time. Also, should look
  at OpenCL kernels for the core algorithms. This is good anyway as it
  allows to focus even more on achieving a clean separation between
  the framework and the alogrithms.

  The key lesson is to make the underlying datastructures as simple as
  possible while proving a good access layer on top of them for use
  from C++. For example: unstructured grids are stored in a set of
  flat contiguous memory chunks but a complete STL-type access layer
  should exist.
  
* December 13th

  The first step is to remove the HDF5 implementation from Lucee and
  use the one provided in txbase. The reason for this: no need to
  rethink the whole hdf5 I/O as it works well already for Facets,
  Nautilus and VORPAL.

  The longer term goal is to replace the use of Loki with Boost. Also,
  in general it is best to start using the Boost libraries as soon as
  possible.

* December 8th

  The gyrokinetic edge code will be based on Lucee but will not
  include all the fluid solvers, at least initially. The idea is to
  keep the GK work separate from the fluids work and also possibly
  make the GK solve code more application-specific that the general
  purpose Lucee code. This can be achieved in a number of ways: one
  way would be to provide a class derived from SolverIfc which
  implements the gkeyll algorithms.
  
  The name of the GK code will be gkeyll, pronounced as "Jekyll" as in
  Dr. Jekyll and Mr. Hyde.

** What to do with the TableDescription class?

   Will this ever be used? I do not think so, at least not in this
   programmatic way I have it now. Perhaps it is best to remove it
   from the repo and think of another way to interactively document
   the code. This does not make much sense in the situation in which
   lucee itself is not interactive. When it does become interactive,
   however, this interactive help might be very useful.

* December 7th

  Downloaded and installed gsl-shell. This is a wrapper around the GSL
  library. It also includes simple plotting via the AGG 2.0
  library. The cool thing about this is that the standard Lua
  implementation is not used. Instead, the LuaJIT 2.0 just-in-time
  compiler is used. LuaJIT creates on-the-fly compiled code from Lua
  with performace (as claimed on the LuaJIT website) close to
  optimized C. This opens up the possibility of using LuaJIT instead
  of standard Lua in Lucee. Something like can speed up thw the parts
  of Lucee that are written in pure Lua, in particular sources or
  fields initialized with lua function. Further, this opens up the
  possibility of implementing complete updaters in Lua itself.

  LuaJIT also provides a FFI to C code compiled into shared
  libraries. This is similar to ctypes in Python. The possibilities
  here are endless: one can imagine creating a plug-in architecture
  for Lucee that would allow calling code written by someone else not
  having direct access to the Lua source code.

  It should also be possible to use GSL shell code from Lucee
  itself. The problem here, of course, is the GPL licence under which
  both GSL and GSL-shell are shipped. However, I am currently already
  using GSL in the radiation transport solver. Perhaps in the future I
  should add a flag to the CMake build that disables all the GPL code
  when so requested.

* December 3rd

** On unstructured grids

  Need to rethink the manner in which the grids and array classes
  work. The observation that structured grids are a special case of
  unstructured grids should lead to a better design of the Lucee grids
  and fields. The method of looping over the grids should be using
  element, incidence and entity iterators. These iterator classes
  should stand outside the grids themselves and take the grid as a
  constructor parameter. This allows creating the proper iterator
  based on the grid type: for cartesian grids there would be no need
  to maintain explicity connectivities while for the unstructured
  grids the connectivity list would be used. In this case it would
  become easy to use a cartesian grid where a unstructured grid is
  expected.

  The current GridElement classes need to be split into two pieces:
  first, the interface to access the data (volumes, normals etc) and
  the second, to be used by the iterators for iterating over the
  elements themselves.

  The other change is that both the incidence and element iterators
  should allow attaching an "entity" to them. This is the correct way,
  I think.

  The second important change is to allow for multiple nodes in a
  field. This is essential for the nodal DG method I need to implement
  for solving the GKE. Here the idea is to create another class called
  NodalField that allows for storage of nodes.

  In the next three years I want to create a FusionHub analogous to
  NanoHub. In this each "component" should be available as an "App"
  perhaps driven by either a Qt UX or a HTML5 UX. The best would be to
  have a HTML5 type UX for ease of coding.

** Need to now work on this seriously

   I have been working on Lucee in a lackadaisical manner. The code is
   of course very clean but progress has been slow. This is because
   this is not a full-time endevour for me but a "burn the midnight
   oil" type of thing. Now that I am moving to PPPL I need to work on
   this much faster and create a powerful system that will do a lot of
   plasma physics problems.

   There are certain classes which I wrote but never use. These need
   to be removed from the system. A basic cleanup is needed before
   going to Princeton. Also, it is important to get rid of my own Hdf5
   I/O so I can use the one provided in txbase.

* November 12th

  Need to implement the 10m system in Lucee based on the eigensystem
  computed in Tech-Note 1013.

  To test the 10m solver I need to implement an exact Reimann
  solver. This should not be much harder than the Euler Reimann
  solver. One never knows till one does it, though.

* November 8th
  
  For 10-moment system the primitive eigensystem needs to be computed
  using Maxima. Then this should be converted to the conserved
  eigensystem. One option is to auto-generate the C code from Maxima
  for the eigensystem calculation.

** Done on Nov 11th

   Written up, checked in and online.

* October 24th

  Completed implementation of semi-implicit integration scheme. Tested
  with dispersive Euler, although much more extensive tests are
  needed. Turns out that the dispersive Euler problem with
  semi-implicit takes 5X longer to run than with RK4. This seems a bit
  excessive, but not surprising. The Rk4 scheme needs 4 evaluations of
  the source terms. The semi-implicit scheme needs 1 evaluation of the
  source, 1 evaluation of the source Jacobian and 1 linear solve. The
  linear solve probably makes the scheme very expensive. Also, there
  is too much copying of matrices being performed. For now I am not so
  worried about this but will need to improve soon.

** Two-fluid source terms need to reformulated

   The two-fluid source terms need to be reformulated in the following
   way: the current and the Lorentz sources from/for each fluid need
   to be put into a single class. The reason for this it allows the
   correct computation of the source Jacobian which oterwise misses
   the coupling terms in the Jacobian between the electric field and
   the fluids. This should generally not be a problem as the source
   Jacobian needs to be known only approximately, but might turn out
   be to be important when trying to take dt large than allowed by
   plasma frequency.

* October 23rd

** Redoing the two-fluid shock simulations

   These need to be redone after the fix to RK4. I already redid the
   dispersive Euler simulations and the results do look very
   different in some cases.

** Regression testing

   Need to start adding regression tests. It is really important to
   establish confidence when existing code is modified. Can use txtest
   from Tech-X or the one I wrote for WarpX.

* October 21st

  Fixed a nasty bug in the Rk4 integrator in the
  GridOdePointIntegrator class. Turns out this was causing the
  plasmabeach problem to fail. What is surprising is that other
  twofluid problems with sources worked at all.

** Rerun all problems with sources in the journal

   Need to rerun all the problems that use wave-propagation scheme and
   have sources in them. SUCKS.

* October 19th

** VERY bizarre behaviour

   Turns out that the solution of wave-propagation updater with and
   without limiters are very different for different CFL numbers! This
   is unbelievable!!

   RESOLUTION: This is really not a bug. The issue here is that when a
   discontinuity is initialized too close to a boundary and limiters
   are not applied, the solution in the ghost cell can get
   contaminated with oscillations. Then, this completely changes the
   interior solution as it propagates in the interior, completely
   screwing up the solution.

** Minimum density and pressure in Euler equation

   Need to add a flag with additional input variables that allow
   setting a lower bound on the density and pressure in the Euler
   equation class. This is something I dislike, but otherwise it can
   be difficult to do real problems.
   
* October 15th

  In terms of work before getting to Princeton, I need to do the
  following.

** TODO Complete the Facets PoP paper    

   Complete the draft and then let Alexei and Scott complete. 

** TODO Implement 2 schemes from Peterson and Hammett paper    
    
   The Poisson solver is already written. Next step is to create an
   updater to use the Poisson solution and compute the edge
   velocities.

   Then implement the SuHu and Arakawa schemes. Also compare with
   multi-dimensional wave-propagation scheme.

** TODO Implement a first-cut hybrid FV/DG scheme

   This task might be harder to complete before APS. However, getting
   it done is important.

** TODO Divergence preserving scheme for two-fluid equations

   This is needed to get the 10-moment paper completed.

** TODO Complete a 10-moment paper for PoP

   For this the cold-plasma dielectric is required. NOT REALLY. Seems
   like using a low-temperature Euler fluid for the electrons will
   also do.

* October 14th

  Need to implement a mechanism that would allow the creation of
  objects (not derived from LcBasicObj) from Lua scripts. This would
  then allow getting of field pointer objects (write and read) that
  can be used from Lua to access the field components.

  This should not be too hard, but will need addition of classes like
  LcObjRegistry and LcLuaModuleRegistry that do not rely on existence
  of a base class.

  One can then imagine doing (assume q is 2D field)
#+BEGIN_EXAMPLE
  ptr = q:creatPtr()
  q:setPtr(ptr, i,j)
  for k in 0, ptr:getNumComponents() do
    ptr:set(k, 10.0)
  end
#+END_EXAMPLE

  Another use could be in updaters that take in multiple pointers and
  compute some quantity.

** Updates on this

   There is no need to do this. The current system will work just by
   providing a class LuceeMod as a base class for objects that can be
   made from Lua.

** Notes on documentation

   Now that some experience has been gained writing the simulation
   journal, it is time to document all the updaters, BCs etc
   used. Some usage hints on how to do this from Lua will also need to
   be given.

* October 6th

  The dual Yee scheme is a bit tricky to implement. One needs to first
  update the magnetic field and then the electric field. The magnetic
  field solve needs to extend to the ghost cell on the upper edges of
  each side. This will mean that the upper edge magnetic fields will
  have the correct values when updating the upper skin electric field.

  Note that the magentic field BCs need not be applied at all. This is
  because the x-derivative of Bx or y-derivative of By does not show
  up in the Maxwell equations.

  Added a new variable to the curl updaters to allow specifying ghost
  cells to update. With this and the careful application of BCs the
  conducting wall BC problem with dual Yee mesh seem to work. Need to
  test and document.
  
  A final trick (not yet implemented) is to compute the magnetic field
  at -dt/2. This is needed to allow storing the electric field at
  integer time-steps and magnetic field at half time-steps.

* October 5th

  Have not updated notes for a while as I have not done much
  development of Lucee. However, I have written a lot of journal
  entries in the last few weeks, testing Euler solvers and Maxwell
  solver. Also did some 1D two-fluid solver.

  It seems that it would be relatively easy to make Lucee
  interactive. The line-editing library libtecla can be used to give a
  pretty good command line interface to Lucee. A class needs to be
  added to the system that allows calling the Lua interpreter from a
  program. This will allow interactive use as well allowing attaching
  Lucee to say a GUI or a web interface.

* September 6th

  Verification and documenting the test cases and the solution plots
  is a tedious and time-consuming job. It is obvious why the barrier
  to make research reproducible is so high: it takes too much
  work. One might be tempted to think that the time is better spent in
  adding new features, adding new algorithms etc.

  However, I firmly believe that such an effort will pay off in the
  long run.

* September 5th

  Completed a Journal Entry for testing the PeriodicPoisson2D
  updater. Verified that it works. Writing up an entry takes
  work. Developing the disciple to maintain the journal will be hard,
  but will be very useful.

* September 3rd

  Tested Poisson solver on periodic domain. Seems to work fine. Need
  to write a Journal Entry for this.

  One useful updater to have is one that can compute
  finite-differences on a rectangular mesh. This could be then used in
  many different places. What could a potential syntax look like? The
  first step is to specify the stencil. For this one can use something
  like
#+BEGIN_EXAMPLE
  centralDiff = Stencil.Linear {
    dir = 0,
    indices = {-1, 0, 1},
    coefficients = {1.0, 2.0, 1.0},
    dxFactor = 1.0,
    dxPower = 2.0,
  }
#+END_EXAMPLE

  This specifies a second derivative using a central difference
  stencil. This stencil can then be used in a
  Updater.RectFiniteDifference object to compute the specified stencil
  on a rectangular grid.

  It would be more difficult to specify a 2D/3D stencil. One simple
  option might be allow the stencil to be isotropic. I.e. the same
  linear stencil would be applied in each direction.

  For more complex multiple dimensional stencils a more complex system
  will be needed. However, the Stencil.Isotropic and Stencil.Linear
  will do for now.

  The Lucee::RectStencil will need to be templated over NDIM and take
  the grid and field as input. The same stencil is applied to each
  component of the field.

* September 2nd

  Completed a unit-test for using FFTW. The only "trick" to this is
  that the FFT is not normalized and so the inverse transform needs to
  be divided by number of elements in the array. Otherwise does not
  see like very difficult to use.

  Next step is to write a PeriodicPoisson2D updater that solves
  Poisson equation for use in the incompressible solver.

** DONE Completed Poisson solver. Some concerns

   Completed the PeriodicPoisson2D. The solution "look" correct, but
   there is something funky. The results do not match the Python
   computed solutions. This could be okay as the solution is only
   determined to a constant. However, the *shape* of the solution is
   not the same. Need to investigate this before moving on.

   [September 3rd] This worked correctly the first time! The problem
   was the Python script that I was using to compare. Lesson: test the
   test code first.

* September 1st

  Getting back to Lucee after a while. Need to implement the Arakawa
  and perhaps Suresh-Huen algorithms from Peterson and Hammett
  paper. Then, need to implement a DG scheme and compare.

  For the Poisson solver I have integrated FFTW into lucee. Also, I
  have extended Arrays to allow templating over std::complex types. In
  fact, I never knew this type existed.

* August 22nd

  Seems that I forget what I think.

** Notes in pre of PPPL move

   First, I need to finish the mapped grid code. For this the geometry
   calculation code needs to be completed. Then, a method that returns
   a const reference to the coordinate system object needs to be added
   to the LcStructuredGridBase class. Then the wave propagation
   updater needs to be modified to use this instead of the coordinate
   aligned coordinate system.

   I also need to work on the 2D incompressible flow solver with DG
   and DG/FV hybrid. This needs to be done soon.

   Move to MPI needs to be done. This should not be too hard but also
   need to provide access to the MPI object from Lua script to figure
   out rank, number of processors and other basic things.

   Update the documentation with description of all implemented major
   updaters, grids and fields. This is not hard at this stage when the
   amount of code is relatively small, but can turn into a nightmare
   later. So DO IT NOW.

** Papers notes

   Need to write up the text of a 10-moment paper. This has been
   delayed for long enough and will be delayed indefinitely if it does
   not happen before the PPPL move.

   Need to write the text for a PoP paper on jets. JLo can be the
   first author. This should also be submitted before January.

   Need to explore the charge and divergence preserving two-fluid
   algorithm. Will this really work? How would one apply BCs? How
   would it be generalized to general geometries?

** Tomato timer

   Need to get one of these so I can work in 25 minute chunks. Could
   help focus on task at hand rather than switch between multiple
   things at the same time.

* August 12th

  Now mapped grid can take in a field containing vertex coordinates
  and initialize itself. One disadvantage of this scheme is that the
  user needs to specify too many ghost cells (vertices) to support the
  wave propagation scheme. For DG the number of ghost cells would be
  more. This is usually not a problem if the vertices are being
  computed from functions, but can be a significant issue if they are
  being read in from a file.

  Even with functions this can be a problem: consider the case when
  the function uses square roots. If the ghost cell computational
  region has negative coordinates this can cause the code to core
  dump.

  For the file reader this will pose a challenge. First, the file will
  need to have one extra layer of vertex data than cells in the grid
  as this is needed to initialize the grid correctly. Then, a flag
  could be passed to the MappedGrid class to itself construct the
  ghost vertices by extension on edges outside the domain.
  
  One option is for lucee to compute the ghost cell vertex
  coordinates. This is in general easy, but could be a significant
  problem for corner cells.

  This will also not work when trying to make multi-block mapped
  grids.

** BTW: What is happening to making Lucee parallel?

* August 10th

  How to create mapped grids? The key to these meshes is that the
  vertex coordinates must be provided by the user. What this means is
  that the constructor for mapped grids must take in a field storing
  the vertices. These vertices could be computed in the usual way,
  i.e. using Lua functions or read from HDF5 files.

  The advantage of this scheme is that it decoupled the calculation of
  the vertices from the creation of the mapped grid. The disadvantage
  is that it forces the user to be careful in computing the vertices
  as the ghost cell vertices need to be also computed. One option to
  get around is to let the MappedGrid class to compute the ghost
  cell vertices.

  For example, one would have
#+BEGIN_EXAMPLE
  compGrid = Grid.RectCart2D {
    lower = {0.5, 0.0},
    upper = {1.0, 2*Lucee.Pi},
    cells = {10, 10},
  }

  vertices = DataStruct.Field2D {
    onGrid = compGrid,
    -- [x, y] coordinates of each vertices
    numComponents = 2,
    ghost = {2, 3},
    location = "vertex",
  }

  function calcVertices(xc, yc, zc)
    -- compute coordinates
    return xc*math.cos(yc), xc*math.sin(yc)
  end
  vertices:set(calcVertices)

  grid = Grid.MappedGrid2D {
    cells = {10, 10},
    vertices = vertices,
  }
#+END_EXAMPLE
  
  The *cells* table is required (although redundant) as it allows
  Lucee to check the shape of the *vertices* field and compute if it
  should create the ghost cells. Otherwise, perhaps it is best to
  explicity tell Lucee to create the ghost cells, as follows
#+BEGIN_EXAMPLE
  grid = Grid.MappedGrid2D {
    cells = {10, 10},
    vertices = vertices,
    createGhost = true
  }
#+END_EXAMPLE

* August 8th

  The concept of factories seems very flawed. Need to get rid of both
  the datastructure and grid factories. Does not make any sense to go
  through all the indirection of making factories. Perhaps it is
  easiest to just do all the work in the object rather than the
  factories. In fact, presently, a factory object is created, its
  create() method is called immediately and then copied over using the
  operator=(). This seems very wasteful and indirect and not needed.

** Got rid of factories

   All factories for datastructures and grids are now gone.

* August 5th

  Added a new repo called ammar-simjournal to store simulation notes,
  input files, etc. See the index.rst and linked files for motivation
  and what will go into this repo.

  Each journal entry needs to be labeled. For example, je1, je2,
  etc. Each simulation needs to be labeled. For example, sm1, sm2,
  etc. In general, a single journal entry will describe several
  simulations. Hence, there will be fewer journal entries than
  simulations.

  Each simulation should have directory for itself, for which the Lua
  input, post-processing scripts, data etc are stored. This will make
  it easy to look up a journal entry and from there navigate to the
  simulation directory.

  If followed consistently, this will be a good way to do reproducible
  research. The scheme is simple and needs to be for it to be
  reliable. A complex scheme is less likely to succeed. No need for a
  database. The version control itself, combined with the search
  capability of Sphinx, is a good almost-permanent, globally
  accessible and persistent "database".

* August 3rd

  The mapped grid class skeleton is written. This needs to store the
  extended local region so that a linear index is computed from the
  (i,j,k) index into the grid.

  This will allow a derived class that stores the data using a
  space-filling curve.

  There is an issue with the way factories work. Seems like the
  geometery would have to be built in the factory. One way around this
  would be for the MappedCartGrid to take a field with the vertex
  coordinates and then build the geometry in MappedCartGrid. So the
  factory will build the vertex coordinates and the MappedCartGrid
  does the actually geometry calculations.

* July 31st

  How to handle axisymmetric simulations? In the past we have expanded
  the d/dr term and moved the algebraic term on the RHS and treated
  these as sources. Perhaps this is what I should also do in
  Lucee. However, a better approach would be to incorporate the
  axi-source term in the d/dr flux evaluation using the f-wave method.

** Better way to do source

   Should extend the getData() to the following

#+BEGIN_EXAMPLE
   double getData(unsigned nfld, unsigned ncomp);
#+END_EXAMPLE

   where nfld represents the field number and ncomp the component
   inside the field. Hence, a Lorentz force calculator could expect
   three fields: the fluid conserved quantities, the electric field
   and the magnetic field. It could do

#+BEGIN_EXAMPLE
   void getSource(...)
   {
     // fluid is 0th location
     rho = this->getData(0, 0);
     rhou = this->getData(0, 1);
     rhov = this->getData(0, 2);
     rhow = this->getData(0, 2);

     // Electric field is 1st location
     ex = this->getData(1, 0);
     ey = this->getData(1, 1);
     ez = this->getData(1, 2);

     // Magnetic field is 2nd location
     bx = this->getData(2, 0);
     by = this->getData(2, 1);
     bz = this->getData(2, 2);
   }
#+END_EXAMPLE

   The base class would have map the two indices to fetch data. The
   advantage of this scheme is that it allows arbitrary number of
   inputs and eliminates the need for auxillary variables completely.

* July 28th

  Completed first two-fluid Lua program. Needed some work to get
  indexing and initializing correct, but now it works! Got a first
  two-fluid simulation of 1D shock.
  

** Timing notes

   Compared with wave in Nautilus. Exactly matched Nautilus
   results. The solver in lucee is marginally slower. Need to figure
   out why.

   Shark shows significant time spent in the rk4() method. The timing
   is very sensitive to memory allocation/deallocation. These should
   not be done in inner loops.

* July 27th

  Added LorentzForceSource and CurrentSource classes. These should
  allow simulating two-fluid equations.

* July 26th

  Completed and tested RK4 ODE integrator. Next need to write an
  updater that uses this to integrate sources.

* July 25th

** Timing Lucee

   The Lucee 2D Wave solver is as fast as the one in Nautilus. This
   was tested on a 2D Riemann problem on a 400x400 grid. First, this
   is not surprising as both solvers work almost exactly the same way
   and hence in a way prove that the Lua programming adds no
   measurable overhead. However, the question remains: how to make the
   Lucee wave solver *faster*?

   There are two aspects to this: make the Euler waves() method faster
   and also make the wave scheme itself perform better.

   First step here is to profile the code. For some strange reason the
   Shark profiler on the new Mac is unable to figure out the function
   names. Perhaps Tau?

   Wasting time on optimization at present is probably not a good idea
   but needs to be kept in mind for future work.

* July 24th

  Trying to figure out how to incorporate sources in the system. For
  this added a class GridOdeIntegrator that takes a grid and an
  arbitrary number of input variables and a grid. It has a pure
  virtual method integrate() that evolves the ODE to a specified time.

  What should be the Lua API? Something like

#+BEGIN_EXAMPLE
  elcLorentzForce = Source.LorentzForce {
    inpComponents = {0, 1, 2, 3, 4}, -- takes rho, rho*u, rho*v, rho*w, Er
    outComponents = {1, 2, 3}, -- computes rho*u, rho*v, rho*w and Er sources

    -- lorentz force specific inputs
    charge = elcCharge,
    mass = elcMass
  }
#+END_EXAMPLE

  Then the GridOdeIntegrator can be used like follows

#+BEGIN_EXAMPLE
  sourceIntegrator = Updater.GridPointOdeIntegrator {
    scheme = "rk2",
    terms = {elcLorentzForce, ionLorentzForce},
  }
  sourceIntegrator:initialize()
  sourceIntegrator:setIn( {q} )
  sourceIntegrator:setOut( {qNew} )
#+END_EXAMPLE
  
  The GridPointOdeIntegrator derives from GridOdeIntegrator and uses
  values only in the current cell to solve the ODE. I.e. creation of
  ODEs from FD stencils is not possible in this particular
  integrator. However, other derived classes can use stencils to do
  this.

  Wrote PointSourceIfc class to provide base class for computing
  sources that depend on values in a single cell.

  A general algebraic source can be written as follows.
#+BEGIN_EXAMPLE
  algSource = Source.LuaFunction {
    inpComponents = {2},
    outComponents = {2, 4},
    source = function (x, y, z, rhov)
      return -gravity*rhov, 0.0
    end,
  }
#+END_EXAMPLE

** Notes on LuaTable::getFunctionRef

   Added test for this method. Seems to work just fine. Calling a Lua
   function from C code is simple but can be tedious. A wrapper class
   or method is needed. This method can then be passed the lua_State
   pointer and the function reference along with the input
   variables. It should return the output variables returned by the
   Lua function.

   It would be interesting to test what performance hit this
   entails. Perhaps quite significant if done in an inner
   loop. However, the ability to call a Lua function is very valuable
   for initialization as well as for quickly testing ideas. Lua
   functions can be replaced by hard-coded C++ if needed.

* July 22nd

  Completed PH Maxwell equations. Also wrote up the eigensystem and
  put it in the manual as well as my website.

  Tested PH Maxwell against Maxwell for 2D pulse-in-box problem. Seems
  to work fin, though more careful testing is needed.

  Also, one thing is to look the BCs for PHM carefully. These seem a
  bit non-obvious and should be looked into.

  Added the RST form of the technical notes to the manual. This now
  puts the Lua program documentaion as well as detailed techincal
  notes in one place.

** Testing and verification study

   Need to create a verification repo in which all Lua programs used
   in verification of equations and solvers in Lucee is
   performed. This should study convergence of each scheme and a large
   number of problems to give confidence that the equations and
   solvers are implemented correctly.

* July 7th-9th

  Completed wall BCs for zero-normal and zero-tangent vector
  fields. Also implemented Maxwell equation class. Tested with 2D
  pulse in metal-box problem. Need to compare with FDTD solver.

  Hooked in txbase into Lucee to allow use of MPI stuff. Added a comm
  pointer to the globals object.

  Next, need to implement PHM equations and the correction equation
  classes. Then test using some current and charge source problems.

  For FDTD need to implement the PEC wall BCs.

  Need to write a OdeIntegrator base class that integrates ODEs on a
  grid. A derived class from this could be used to create an updater
  to do source updates using an operator split-scheme.

  Real important to make Lucee work in parallel. This needs bringing
  in the txbase MSG library into Lucee and creating
  decompositions. Also, the loggers need to be exposed to Lua.

  Navier-Stokes via compact Pade schemes.

** Work on manual

   This is coming along well. Need to get basic stuff documented
   before the system gets too large and documentation becomes hard.

** A system to label simulations

   Label them sequentially with a four digit number. Then use two
   letters for name of person and finally a short name for the
   simulation. For example, 1034-ah-eulershock.

* July 6th

  Thoughts on wall boundary conditions. Wall boundary conditions are
  applied, say to fluids, by setting normal component to 0 and not
  changing the tangential component. How to specify this in Lucee?

  One way would be to create a BC object which gives the type of BC to
  apply. Something like

#+BEGIN_EXAMPLE
  rhoBc = BoundaryCondition.Copy { components = {0} }
  velBc = BoundaryCondition.Wall { type = "zero-normal", components = {1,2,3} }
  funcBc = BoundaryCondition.Function { components = {0}, func = bcFunc }
#+END_EXAMPLE

  Then can then be used in a BC updater.
#+BEGIN_EXAMPLE
  bcUpdater = Updater.BcUpdater {
    # stuff
    dir = 0,
    edge = "lower",
    boundaryCondtions = {rhoPrBc, velBc, funcBc}
  }
#+END_EXAMPLE

*** July 9th updated: BC implemented.

** Bug due to unlimited Lua stack growth

   It seems that there was a unlimited stack size growth in Lua. The
   call luaL_register pushes something on the stack but does not
   remove it. Hence, an explicit pop needs to be called to avoid stack
   overflow. It seems one needs to be very careful with Lua calls.

** Bug in array destructor

   There was a major bug in the Lucee:Array dtor. The code was
   decrementing the useCount but not deleting it when done. This lead
   to a huge consumption of memory in the WavePropagationUpdater.

* July 4th

  Updates to manual. Added method to compute primitive from conserved
  variables (and visa-versa). Added a globals class to store global
  variables. Now Lucee output is prefixed with input file name.

* July 2nd

  No work on Lucee for a while. Focused on Nautilus unstructured
  meshes.

  One can imagine adding lua methods to HyperEquation class to compute
  primitive variables, fluxes and speeds. This will allow computing
  say pressure for output, for example.

* June 12th
  
  Tried to move the HDF5 I/O to TxBase provided I/O. Unfortunately
  this does not work. There are some bizzare problems with resolving
  the calls to templated member functions. For now, I am abandoning
  this effort. Will focus on using the TxMsg system instead. Wasted
  the whole weekend figuring this out.

  The next major step is to integrate MPI into lucee. This might not
  be so hard but needs to be carefully thought out.

* June 9th

  Add MPI and finish general geometries, perhaps even the triangular
  meshes. Also implement the DG (PmPn) schemes on these meshes.

  Need to go over the derivation of the cold relativistic fluid
  Riemann problem very carefully. Perhaps I am missing something as
  the Roe average speed does not match the root of the one computed
  from the conservation equations.

* June 2nd-8th
 
  Completed and uploaded notes on MUSCL/Hancock scheme. Now have the
  general geometry MUSCL interpolation figured out. Basically will use
  the one from the "Red" book.

  Started working on a note on cold relativistic fluid equations for
  use in laser-plasma applications. Turns out that Randy's work on
  pressureless fluids can be rather easily extended to the
  relativistic case. However, do not have a way of computing the
  intermediate velocity yet. Perhaps should look at a relativistic Roe
  solver and take limits as pressure vanishes. (This looks rather
  simple. So why does it not appear in my derivation?)

* June 1st

    Should play around with the cold relativistic fluid
    equations. Could use FDTD Maxwell solver or a collocated
    solver. Try out MUSCL, Wave and perhaps DG schemes.

* May 31st

  Create empty user-manual type documentation RST file. Need to start
  working on this.

  Need to greatly improve code documentation using doxygen. To make
  this more systematic should start off with one class (say Array or
  LuaTable) and document it thoroughly to get a feel of how to do the
  rest. The documentation should be detailed and as complete as
  possible.

  Added a method to apply boundary conditions using a function. The
  SructGridField class does not have any unit tests. Need to add
  these. [Done, also added tests. For now tests for rect-grid are also
  bundled with the structuredg grid class. Need to disentangle this
  stuff.]

  Next major assault will be to make the code run in parallel. To
  simplify the coding create a base decomp class for structured grids
  and make on of the derived classes a simple NxM decomp. The
  automatic decomposition can be added later.

*** TODO Consider using smart pointers to pass Grid pointer to StructGridField class.

* May 26th

  Implemented periodic boundary conditions. One issue is what to do
  with the corner cells. For example, when applying periodic BCs in
  direction 0 the corner cells do not get updated. Not sure how to
  handle this yet. (The issue is that periodic in X might actually
  just mean that. Periodic in *both* X and Y means all corners need to
  be updated in a periodic manner too.)

  Added a skeleton for copy BCs. These need to be
  completed. [DONE. May 27th]

  Then need to add general "copy" BC function that takes an array of
  coefficients to multiply before copy.

  Then need to add a function BC to the StructGridField class (as it
  knows the centroid coordinates). 

  Should either clean up the lucee-studies repo or create a new one
  for examples.

  Need to clean out the code documentation. Code should be documented
  using doxygen. However, the usage in Lua should be documented using
  Sphinx. Need to start on the latter. Also, add more detailed
  documentation to the respective header files.

  For Lua documentation create one page for Grids, one for Fields and
  one for Updaters. Describe each in detail with examples. Also try
  and give full working examples.

  Allow text output from slab RTE solver. Then make HDF5 optional and
  conditional shield all the HDF5 code both in CMake and code.

  Complete the white-paper on Lucee as product. Perhaps need to play
  around with WPF as a possible UX library.

* May 25th

  Implemented waves() method in the EulerEquation class. Tested in 1D
  by comparing to Sod-shock problem. Results compare well with exact
  solution. However, still need to compare with previous results from
  miniwarpx to ensure that the results are not too diffuse.

  Also compared with Muscl-Hancock scheme. The MH scheme compares well
  with Wave. However, small oscillations are seen in MH that are not
  present in the Wave scheme. However, it is impressive how a simple
  numerical flux (Lax) can give such good results. Hence, it seems
  that MH could be a good scheme to implement and make available as a
  production scheme.

  The "epsilon" limiter in van Leer's paper gets rid of the
  oscillations seen with the minmod limiter. Need to test on smooth
  problems.

  Should start thinking on how to do MUSCL as general updater on
  rectangular meshes.

  Also need to document the Roe averages for the Euler equations in
  Tech-Note 1007. (This is so simple, no need)

  Turns out that the 2nd order Muscl-Hancock scheme as implemented
  does not preserve positivity. However, the 1st order Muscl-Hancock
  scheme does (limiter = "zero"). The internal energy looks really
  bad. In fact, turns out that the exact solution with even tiny
  background density and pressure has a spike in it.

* May 24th

  Added a method writeToTxt that allows writing data-structs to a
  plain text file. This allows easy reading into Matplotlib. The data
  in each cell is written on one line. The first NDIM entries are the
  coordinates and the next numComponent entries are the values stored
  in the field at that location.

  Implemented characteristic limiters to MUSCL/Hancock algorithm. The
  results still look very crappy. FIXED!!

  Turns out that the problem was that I was not using the estimated
  values at the edge but using the previous time-step solution. Also,
  the other problem was with the incorrect indexing. The first layer
  of ghost cells need slopes and predicted values computed to ensure
  that the first and last cell in the domain are updated correctly.
  
  One issue in implementing a general MUSCL/Hancock algorithm is how
  to do the predictor step for a general system of equations. Perhaps
  just conserved updates are enough?g
  
** TODO Fix the muscl-hancock script to adjust dt properly

   As implemented now the muscl-hancock scheme will not take a larger
   time-step even if allowed. This needs to be fixed.

* May 23rd

  Implemented Hancock-MUSCL algorithm as described by van
  Leer. Boundary conditions really, really need to be implemented now.

  Characteristic limiters are required. Add a method to project a
  vector on left eigenvectors and back to right eigenvectors.

* April 10th

  Although basic unstructured grid data is stored in flat arrays the
  wrapper classes to get OO access to the data and incidence lists are
  becoming complicated. Need to relook at this more carefully to make
  a cleaner solution. At the least, each of the grid element classes
  needs to be put into its own file to make the LcUnstructGridElems
  file less messed up. Then, the iterator classes inside UnstructGrid
  need to be finished.

  One option is to add methods to the UnstructGeometry class to allow
  insertion/access of data using methods without direct access to
  memory. The grid and creator classes would still be friends to allow
  easier creation of element wrappers.

* April 8th

  Really good progress on unstructured grids. Now have basic code to
  read mesh from GMV files, write to HDF5 and also a start on iterator
  classes. The next step is to write incidence iterators and then
  construct the incidence lists needed.

* April 1st

  Started work on unstructured grids. The basic idea here is to store
  connections in a sparse format and minimum required geometry. In the
  bare-minimum case only nodal coordinates are stored and cell->node
  mapping is stored.

  The connectivity (d->dprime) is stored in 2 arrays: an offsets array
  and an index array. The n-th element of dimension 'd' is connected
  to the elements index[j], where offset[n]<=j<offset[n+1]. The reason
  to have the offset array is that allows fast access to the
  connections in case the mesh is composed of mixed type of cells
  (tri/quad or tet/hex/pyramids).

  The other connectivies (besides ndim->0) is computed on demand when
  needed the first time.

  A set of wrapper objects need to be written that put a OO interface
  on top of these raw data. For example, iterators need to be written
  to walk over all elements of a specified dimension. Recursive
  iterators should be constructible, i.e., it should be possible, for
  example, to iterate over all cells, the faces connected to each cell
  and the edge connected to each face (in a nested loop, for example)

  The basic data is stored in flat arrays for several reasons. First,
  the topology is separated from the geometry and second, flat arrays
  allow straightforward usage on restrictive architectures like GPUs.

** Notes on differential operators on grids

   Two types of differential operators need to be implemented on
   grids: explicit and implicit. The explicit operators can directly
   difference the discrete fields. However, the implicit operators
   need to use some sort of expression templates to delay evaluation
   till required. When the complete expression is created, the
   implicit expression template is then used to fill up a matrix
   (usually) that is then used to perform the implicit update.

* March 29th 

  The problem seems with the multiple indirections required to get
  hold of values in Lucee::Array class. This is not such a big deal if
  the operations are more expensive than the array fetch. However,
  more efficient basic operators (+, *, /, etc as found in valarray)
  are needed.

  After some work the performance of Lucee::Vector seems a bit
  better. It seems that the valarray classes are far more efficient on
  the newer gcc than the one on the home machine (gcc 4.2.1).

  Played around with expression templates from the article
  "Disambiguated glomable expression templates". I think it will be
  beneficial to use implement this technique in Lucee. Then, one can
  imagine a variety of matrix class (symmetric and diagonal are
  needed) that can make the RTE solvers very compact and succinct: an
  almost direct transcription from Siewert's papers. Eventually, I
  want to implement inhomogeneous algorithms for both polarized and
  non-polarized cases.

  Should run Shark on wave-propagation solvers.

*** TODO Figure out a way to find Lapack/Blas on Linux with CMake

    Then make Lucee work on Linux.

* March 28th

  First, Mercurial is giving a lot of trouble. Perhaps the move from
  svn was not worth it.

  Turns out that the Lucee::Array class design is basically
  flawed. The problem is with the underlying store of data as T*
  degrades performace. Seems like I need to move to some sort of
  valarray as an underlying representation of the data.

* March 2nd

  Move lucee to mercurial on bitbucket. The complete history is moved
  over. Easy to migrate and now will delete the googlecode version of
  the code.

* February 18th

  I really need to get back to productive scientific research. What is
  this nonsense amount of time spent on meeting and planning for the
  next one? How can any productive work be done?

  For Lucee, in order of priority: (a) complete hyperbolic solver,
  test with Euler equations, (b) hook in the documentation sytem, (c)
  write documentation.

  Work on the 10-moment stuff. How about design of a vacuum algorithm
  for use in jets? Divergence preserving collocated Maxwell equation
  solver?

* February 4th

  Need to get back to this. One of the first things to do is to clean
  up the documentation and start working on documenting Lua object
  constructors and methods. Integration of the TableDescription class
  into the readInput() methods needs to be completed. Not sure how to
  do this yet, but it is important to get this finished.

* January 22nd

  Completed VectorDescription class and hooked into TableDescription
  class. Next step is to hook the whole thing into the Lua table-based
  creation system.

* January 19th

  Added validity tests in ValueDescription class. Wrote tests for
  values in TableDescription class. Works just fine. Next, need to the
  same for VectorDescription class.

  How to integrate this into the class system to make it work with
  readInput() method is not yet clear.

* January 18th

  Created first-cut implementation of ValueDescription and
  VectorDescription classes. These are incorporated into
  TableDescription class. Each table can have a set of values and
  vectors (for now). Perhpas more comprehensive feature in the future
  will be to add additional elements to TableDescription.

  Next step is to set setVar() variables from Lua table. Other
  elements in the table should be ignored. This can then be chained
  up-the-derivation tree to setup the complete object.

* January 17th

  Finally, I think the transverse solvers are worked out in my
  head. The essential point is that there are two coordinate systems
  for these: the normal coordinate system and the transverse
  coordinate system. Call these RN and RT.

  Then, we have ql, qr local to RN and apdq (say) in RT
  coordinates. So, compute Roe average from local qr and ql. Rotate
  momentum back to global and then to RT. Then, perform the split in
  RT. Rotate bpapdq and bmapdq to global from RT. Then compute
  updates.

  An efficient way to do this is to store the Roe averages in global
  coordinates in an array. Then, only rotation of Roe average to RT is
  needed and the complete Roe averaging procedure is not needed. For
  this, the waves() interface will need to be extended to allow the
  HyperEquation class to set extra data which the wave updater
  stores. For example, the HyperEquation could tell the wave updater
  how much extra data it needs to store per call to wave() and the
  updater then allocates and stores this.

* January 16th

  Need to start work on Lucee again. Need to really ramp up rate at
  which work is being done to get to a usable system by the time PPPL
  move happens.

  - Boundary condition updaters needs to be written.
    
  - Is onGrid really needed for updaters? Each array needs to carry
    its own grid and hence this is not needed. In fact, it can cause
    problems when arrays are being used to update across grids.

  - The WavePropagationUpdater needs to be tested. First Maxwell
    equations and then Euler equations.
  
  - Transverse solvers needs to be completed. This needs to be looked
    over very carefully to ensure that the code is correct.

  - Some thought needs to be given on what efficient methods to
    implemented. Perhaps PPM? 

  - How to couple something like wave with FDTD Maxwell solver?

  - Documentation needs to be started/completed. API documentation
    needs to be expanded (doxygen) and Lua script documentation needs
    to be started.

  - How to automate Lua table documentation? C++ class? Lua tables
    describing data? XML files?

  - Documentation needs to be thought off also in terms of simulation
    templates. I.e. consider a template that describes RTE solver or
    FDTD solver. The script could be complex but only a few inputs
    need to be changed for a new simulation. How to abstract this to
    make the usage of the code easier?

  - How to bring in MPI to the code? Same as warpx/facets? Something
    different?

* January 8th

  Created notes for eigensystem of Euler equations. This is not such a
  trivial matter and needs careful analysis to make sure the Riemann
  problem needed in wave propagation scheme actually is correct.

  Next, need to make notes on wave propagation scheme, specially
  giving a careful treatment of transverse solvers.

  Also, eigensystem for Maxwell equations need to be written up. And
  the details of the FDTD method. In short, everything that can be a
  production algorithm needs to be completely documented so someone
  can understand and cross-check the code.

  How about computing a relaxation system for the 10-moment equations?

* January 7th

  For EM fields the concept of dual meshes is very important due to
  the curl appearing in both Maxwell equations. Hence, it may be
  important to create four spaces: NODAL, CELL-CENTER, EDGE and
  FACE. These would allow storing of vector fields on these
  spaces. The NODAL and CELL-CENTER vector fields would be collacated,
  while the EDGE and FACE vector fields would be staggered. Then, one
  can imagine developing a series of vector opertors that take a field
  from one space to another space. These would include div, curl, grad
  and interpolation operators.

* January 6th

  Figured out the correct way to do the curl updates. The point is
  that there are two updaters needed: EdgeFaceCurlUpdater and
  FaceEdgeCurlUpdater. The first computes the curl of a face-centered
  field and puts it into an edge centered field, and visa-versa. These
  two can be used to create a simulation that solves the Maxwell
  equations using FDTD method.

  The next major work that needs to be done is creation of boundary
  condition updaters. These need to be thought carefully to create
  easy and powerful way to apply BCs.

  An automatic method needs to be developed to make the Lua table
  constructors self-documenting. One way would be for a class to call
  a checkAndReadTable() method that would be called from readInput()
  method that would set variables in the class. This way a class may
  use this facility or may not, depending on how much work the
  developer wants to put into the table validation. If a class uses
  this facility, then the documentation for that class could be
  generated automatically and input safety achieved.

* January 5th

  Completed curl updater. Not tested yet. Used loop over direction
  combined with deflate() method to perform updates. Perhaps not the
  most efficient way to do this, but probably good enough for now.

  Need to check for time-step restriction using CFL condition. Perhaps
  need to put CFL number in input file?

  [Later] This updater is NOT CORRECT. The issue is that the x, y and
  z components are not indexed in a self-consistent manner. I.e. the
  mesh and fields looks like

             i-1                      i                      i+1
  |-----------*-----------|-----------*-----------|-----------*-----------|
  Bx(i-1)    Ex(i-1)      Bx(i)       Ex(i)       Bx(i+1)     Ex(i+1)
  Ey(i-1)    By(i-1)      Ey(i)       By(i)       Ey(i+1)     By(i+1)
  Ez(i-1)    Bz(i-1)      Ez(i)       Bz(i)       Ez(i+1)     Bz(i+1)

  Hence the update formula for By is

  dBy(i)/dt = 1/dx*[Ez(i+1)-Ez(i)]

  while for Ez we have

  dEz(i)/dt = 1/dx*[By(i)-By(i-1)]


  Hence, it seems there should be two updaters: EdgeFaceCurlUpdater
  and FaceEdgeCurlUpdater. The first updates a edge-centered field
  from curl of a face-centered field (in 3D) while the second updates
  a face-centered field from curl of a edge-centered field (in 3D).

  Deleted SolverAssembly class from system. This is no longer needed
  as all simulations will be driven from Lua scripts.

  Should add a PhysConstants module to Lucee so user can do things
  like PhysConstants.SpeedOfLight, PhysConstants.ElectronMass, etc.

* January 1st 2011

  Made a new project to hold build script for lucee and
  dependencies. It now compiles cmake, hdf5 and gsl and then builds
  lucee. Had to add an install target to lucee to install built binary
  into install location.

  To compile with release mode do

  cmake -DCMAKE_BUILD_TYPE=Release

  Debug can also appear here to build with debug flags.

  Figured out an error in WarpX transverse solvers. Essentially need
  to follow 2006 JCP paper carefully, specially Eq 55.

* December 30th

  Fixed slow-down problem with creation of matrices. For this now the
  rotation function in HyperEquation take double* instead of FieldPtr.

  Created a new branch

  https://lucee.googlecode.com/svn/branches/tx-cmake

  to convert to using TX CMake system. Also created a new project og
  Google code to hold the packages needed to build Lucee.

  https://lucee-packages.googlecode.com/svn/trunk

  This uses the TX bilder system to build (for now) HDF5 and
  GSL. Later will add more packages as needed.

  Need to create a lucee-build-all project to hold the script that
  builds lucee and all needed dependencies.

* December 29th

  To get closer to a usable system (a) boundary conditions (b)
  adaptive time-stepping and (c) transverse solvers need to be
  implemented. The task (b) needs to be done in Lua, of course.

  Adding rotations is significantly slowing down the system. In
  particular the rotation of the waves is horribly slow. One option is
  to instead copy data back and forth. Probably faster than all the
  object creation that is happening now.

* December 27th

  Need to figure out the transverse terms for
  WavePropagationUpdater. This need not be the full 3D transverse
  terms but just the 2D terms may be good enough for now. Of course,
  this needs to be done in a direction independent manner.

  Turns out that directional splitting is required to get proper
  advection in 2D. Otherwise the pulse is highly distored. In fact,
  for unsplit schemes the transverse terms must be included to get the
  proper un-distored solution. This essentially indicates that all
  transverse terms need to be included in 2D/3D to get accurate
  solutions.

  Example of a description

#+BEGIN_EXAMPLE
  td = this->getTableDescription();

  td.addObject("equation")
    .setHelp("Equation to solve. Should be a 'HyperEquation' object")
    .setVar(&eqn);

  std::vector<double> defDirs(NDIM);
  td.addOptionalVecTrait<double>("updateDirections", defDirs)
    .setHelp("Directions to update")
    .addOption(0)
    .addOption(1)
    .addOption(2)
    .setVar(&updateDirs);

  td.addTrait<double>("cfl")
    .setHelp("CFL number to use")
    .min(0.0)
    .max(1.0)
    .setVar(&cfl);

  td.addTrait<double>("cflm")
    .setHelp("Maximum CFL number. Should be slightly larger than 'cfl'")
    .min(0.0)
    .max(1.0)
    .setCheck(&checkCflm)
    .setVar(&cflm);

  td.addOptionalTrait<std::string>("limiter", "no-limiter")
    .setHelp("Limiter to apply")
    .addOption("no-limiter")
    .addOption("min-mod")
    .addOption("superbee")
    .addOption("van-leer")
    .addOption("monotonized-centered")
    .addOption("beam-warming")
    .setVar(&limiter);
#+END_EXAMPLE

* December 26th

  Found a bug in WavePropagationUpdater in which apdq and amdq were
  swapped. Works for 1D advection problem. Need to verify second order
  convergence and then test with Euler equations.

  In 2D the y-direction propagation of a pulse is more diffuse that
  the x-direction propagation. Very, very strange. [Later: Found the
  bug! The issue was that the waves, speeds etc are stored in 1D
  arrays while a 2D indexer was being used to set the pointers. Fix
  was to simply use the 1D index to set the pointers. Next to test and
  verify the order and accuracy.]

  How to make table for a block self-describing? One way: create Lua
  table describing the input. For example
#+BEGIN_EXAMPLE
    advDoc = HyperEquation.Advection {
      help = "Linear advection equation",
      speeds = NumVec {
        optional = false,
	size = 3,
	help = "Advection speed in each direction."
      },
    }
#+END_EXAMPLE
  One other option is to do this programmatically.
#+BEGIN_EXAMPLE
    void declareTable() 
    {
      Base::declareTable();
      TableDescription& td = this->getTableDescription();
      td.addNumVec("speeds")
        .setHelp("List of advection speeds in each direction")
	.setMinSize(3)
	.setMaxSize(3);
        .setVar(&speeds);
      td.addString("verbosity")
        .setHelp("Verbosity for console output")
	.addOption("debug")
	.addOption("info")
	.addOption("warning")
	.setVar(&verbosity);
    }
#+END_EXAMPLE

  What are features of a self-describing table? Each table contains
  "traits" (following Enthought) and other tables. Hence recursive
  definition is needed.

  - There are four types of traits: string, number, and vectors of
    these.

  - Each trait can be optional or required.
    
  - Optional traits must have a default values.

  - Each trait (or each element in a vector trait) can take values in
    a range: unbound, one from a set, or inside a range (for numbers).

  - Number of entries in a vector trait can be fixed or unbound.

  - A trait may be present only if another trait is present and/or has
    a particular value. This can be handled in a general way or just
    be restricted to testing for a single one. For example, one can
    imagine constructing a system that checks for a trait and its
    value and then combine these using logicals.

  - A table may be present only if a trait is present or has a
    particular value. Ditto as the previous point.

  A good start would be to code up only the first 4 and leave the
  if-cases to later.

* December 25th

  Added RectCoordSys class. Added derived class AlignedRectCoordSys
  that represents rectangular coordinate system obtained from a
  90-degree rotation. The RectCoordSys has two methods,
  rotateVecToLocal() and rotateVecToGlobal() that rotate vectors from
  and to global frame.

  Make the methods in HyperEquation be pure virtual. Otherwise missing
  functions are not caught at compile time.

  Completed WavePropagationUpdater. Does not yet work.

* December 24th

  More work on WavePropagationUpdater. Nearly completed. Once
  transverse terms are added the localRgn box may need to be extended
  to give effects of corner cells on the first row of cells.

  Should add a numerical flux function to each equation system. Then,
  let the equation system decide which flux to use.

  Perhaps it is important to introduce direction in the HyperEquation
  class. Otherwise non-isotropic systems can not be simulated. One
  option would be to introduce a RectCoordSys class that represents a
  coordinate system as three ortogonal unit vectors. This could be
  then passed to HyperEquation class to represent direction. [Done]

* December 19th

  Add a rotation class to Lucee. This will allow doing 2D and 3D
  problems. Also, add a vector to WavePropagationUpdater to indicate
  which directions to update. This will allow doing time-split
  algorithms from the input file by carefully combining them in the
  Lua script.

  How to do transverse terms in the correct way?

  Move the test updaters to new 'proto' directory.

* December 18th

  Added and tested duplicate() method to Field class. Now duplicates
  can be created from Lua script. Should open up the way to adpative
  time-stepping.

* December 16th

  Now can create a matrix from a raw pointer.

  PPPL may actually happen! In this case I need to start sprucing up
  lucee by documenting it in detail, specially its input file
  scripting format.

  There is no need for the modifications to the directional
  sequencer. Added a new function deflate() to the Region class to
  allow creation of a box with shape 1 in a specified direction.

   The class Updater should be renamed to something else. Perhaps
   Algorithm?

* December 12th

  - Need to modify the directional sequencer. This should work something
    like the following.
#+BEGIN_EXAMPLE
      DirSequencer<2> seq(rgn, dir);
      while (seq.step())
      {
        while (seq.sweep())
	{
          seq.fillWithIndex(idx);
	  // do something at idx
	}
      }
#+END_EXAMPLE

  - Added WavePropagationUpdater. This is templated over
    dimension. Still not complete, but should be easy. DirSequencer
    needs to be modified as described above.

  - How to create a field of matrices? Perhaps create a matrix by
    reusing the memory in a FieldPtr? Once this is done, then Fields
    can be created in the WavePropagationUpdater to store the various
    needed quantities.

  - For allowing for adaptive time-stepping, duplicate() method needs
    to be added to the derived classed of Array.

* December 11th

  - Added directional sequencer. This does two things: first, it
    allows sweeping a region in a specified direction. Second, it
    allows getting indices from a stencil. For example, consider a 2D
    region. We can perform X-sweeps or Y-sweeps. DirSequencer allows
    this.

  - Now error messages from tests are being put into a different
    file. This means only PASSED/FAILED message is printed from a unit
    test and it there are FAILED tests they go into a different file.

   Do I need to add directions back to flux/waves etc methods in
   hyperbolic equations? For example: in wave3D how to do transvere
   corrections? One needs to split X direction fluctuations into Y and
   Z direction fluctuations.

   What to do about rotations?

   A note on FieldPtrs: FieldPtrs can be sent to const
   ConstFieldPtr. Std::vector can be converted to FieldPtr or
   ConstFieldPtr. FieldPtr of given size can be created.

* December 2nd

  Black box testing can only uncover bugs but never prove that there
  are none. To ensure that bugs do not exist one needs to examine the
  structure of the algorithm and prove, mathematically, that it is
  correct, i.e. does what it promises.

  How do we create computational physics algorithms that can be
  trusted by construction?

  In brief the essential idea is: if you select the correct
  mathematical model and create a provably correct algorithm, then the
  steps of verification and validation are not needed, or just a
  pleasant conformation of what you already built into the system. Or,
  even more briefly, lets get it right in the first place.

  How can such a proof-based method be applied to computational
  physics? There are several challenges. First, we need to ensure that
  the chosen mathematical equations describe the physical system to be
  modelled with sufficient detail. This is impossible in general and
  approximations always need to be made. The degree to which these
  approximations affect the physical realism of the model is hard to
  determine and, ultimately, direct comparisons with experimental
  observations must be made. [Scientific Conception of the World]
  Second, once the mathematical equations are selected, a method to
  solve them needs to be developed.

  To select an accurate mathematical model an a priori approach is
  needed. The tradition "validation" step of comparing computational
  results afterwards to experiments, no matter how many, is not
  sufficient to prove that the mathematical model chosen is
  correct. What is needed is a clear understanding of the
  approximations made and if those are appropriate for representing
  the physical system being modeled. For example, often, if a system
  of equations is complex, simplifying assumptions of length and
  time-scales are made. However, although these approximations may be
  valid on a global scale, they are not valid locally, specially in
  regions where spatial and/or temporal gradients of solutions can be
  of the same order as the ignored scales.

  As a first step we can ignore the complexities of selecting an
  accurate mathematical model and focus on developing a provably
  correct algorithm.

  Remark 1: Is this not just the standard "verification" analysis? At
  first sight it seems like it, however, the distinction made in the
  first paragraph holds between verification and what is being
  proposed here. I.e. verification, as it is a post-algorithm and
  implementation step, can only uncover bugs but not prove they do not
  exist. Here, an analysis is being made on what it takes to construct
  a provably correct algorithm. It need not even be implemented [End
  remark]

  Remark 2: Is this not what all numerical scheme developers do?
  I.e. do they not show that their scheme converges, has so-and-so
  order? I submit that this process is only the first step. Even if
  the scheme converges with some order, it is not clear if it actually
  preserves the mathematical properties of the equation system. [End
  remark]

  What is being proposed here is the following. A scheme must solve
  the mathematical equations accurately, i.e. the scheme must provably
  converge to the correct solution in the appropriate limit. However,
  this is not enough. If the mathematical equations have certain
  properties, it must be proved that the scheme satisfies those
  properties. The larger the set of properties the scheme can be
  proved to satisfy, the greater the confidence in having developed a
  correct scheme. Note that this step does not actually require the
  implementation of the scheme in executable code, but only a
  sufficient knowledge of the mathematical properties of the system
  being solved and certain dexterity in manipulating the formulas
  involved in the scheme.

  What about actual implementation? For the scheme to be useful an
  implementation must be constructed. This step is fraught with
  difficulties. First, although our scheme may satisfy a broad variety
  of properties, its implementation is not guaranteed to automatically
  inherit this. This is due to the gap between a programming language
  and the language in which mathematical manipulations are done. A
  reason for the gap is the lack of formalization of the manipulations
  needed in the proofs. [Descartes calculating machine]. This gap will
  not close anytime soon. What is required is a new approach in which
  the scheme can be expressed directly, proofs performed (manually
  would be good enough) and transformed into executable code.

  Remark: The construction of a scheme is not unique: i.e. several
  schemes can be constructed for the same mathematical model. If each
  of these schemes is proved to be correct, then the one with the most
  efficient implementation can be selected. [End remark]

  So the question comes up: given the state of art, what programming
  techniques to adopt to ensure, as far as possible that the
  implementation is faithful to the scheme?

* November 8th

  Field and array classes need to be tested with the alias-ed
  fields. Aliases don't always seem to work, for some reason.

  Turns out that the Field::getSubCompView() method is not returning
  the correct sub-array. The base class methods in Array do not work
  correctly with sliced fields. This is a very important bug to fix
  ASAP. A clue: when using a sliced subComView field one does, for
  example, ez(i,j,0). However, the base class code actually uses the
  index ez(i,j,-2), in case ez points to the 3rd component of a
  3-component field.

  Big fixed! The solution is to reset the indexer and array start
  indices separately. This makes the getSubCompView a very tricky
  method to implement, but it looks likes the only way it can be done.

* November 7th

  Completed alias method for fields. This was relatively simple. Also
  added divergence operator to the structured grid field. Presently
  only works on rectangular grids.

  In the 2D TM Maxwell solver, the boundary conditions need to be
  figured out for the psi (correction) potential.

  Need to add BC updaters.

  Lucee is turning into a mixed OO and procedural system. Which is
  good as not everything needs to be an updater and this simplifies
  the input file code enormously. No endless writing of updater
  anymore.

* November 6th

  Completed TM Maxwell solver in 2D. This is to test ideas on how to
  conserve divergence errors in Maxwell equations.

  Need to write an alias function.

* October 31st

  Numerical flux class needs to be defined. The interface method
  should have the following interface.
#+BEGIN_EXAMPLE
    flux(ql, qr, fl, fr, sl, sr)
#+END_EXAMPLE
  where ql, qr are left/right conserved variables, fl, fr are
  left/right fluxes and sl, sr and left/right speeds.

* October 13th

  Probably should switch to Tech-X CMake system. Need to design the
  basic hyperbolic equation class. The solver should be numerical flux
  based and not wave based. This allows flexibility as the wave
  numerical fluxe can then be used in other schemes like MUSCL, DG
  etc. Somehow, when using wave propagation scheme the system should
  use the wave/fluctuation form of the update formula. The schemes
  should be dimensionally independent, i.e. work in 1D, 2D and 3D and
  on body fitted grids. Hence, one set of updaters should be enough
  for all structured grids.

  In the future I may wish to use unstructured grids.
  
  For documentation I should start using Spinx more extensively than
  now. Each piece needs to be documented carefully. The RTE solver
  needs to be documented and can perhaps serve as a template for other
  documents. GUI/Mouse driven systems like LyX or TeXMac do not work
  documentsfor me.

* October 10th

  Why is a PointerHolder class needed. One can simply store the object
  pointer itself and register the deletion class. ANS: It is needed
  because the new() method can be called after the pointer holder is
  allocated.

  Added a class LuaObjTypeId. This checks type of the object by
  casting to PointerHolder<BasicObj> and getting the stored ID
  strings.

* October 8th

  Working on wrapping Updater in Lua. Completed this. Now updaters can
  be called from Lua. The setIn() and setOut() methods must be called
  before the advance() method is called. Advance() returns a status
  and a suggested time-step. One issue is that the input and output
  types are not type-checked. This may be impossible in the present
  system as the type information is lost in putting stuff into Lua and
  getting it back (Lua stores void* to an object). One option would be
  store the typeid of each created object in the ObjRegistry
  class. Then, this could be queried when needed to ensure type
  saftey.

  Need to start documenting the Lua API.

* October 4th

  Added methods copy() and clear() to Field class. This allows copying
  from a field and setting all field values to given number.

  Also found a nasty bug in the RectCartGrid which was returning the
  incorrect centriod coordinates. Shows need to for more careful
  testing: essentially the getCentriod() method was assuming lower
  bounds of 0.0 for all grids irrespective of actual lower bounds.

  Added accumulate() method to Field and Array classes. This now
  completes basic operations of fields and makes them available from
  Lua, allowing for writing more complex algorithms.

  Should I rename Updater -> Algorithm? Seems like a more natural name
  than updater. One issue is what to do with time? Perhaps the
  simulation time needs to become a global? Not sure what to do yet.
#+BEGIN_EXAMPLE
  grid = Grid.RectCart1D { 
    lower = {0.0}, upper = {1.0}, cells = {100}
  }

  q = DataStruct.Field1D {
    onGrid = grid, numComponents = 5, ghost = {2, 2}
  }

  qOld = DataStruct.Field1D {
    onGrid = grid, numComponents = 5, ghost = {2, 2}
  }

  function initQ(x, y, z)
    local rho, pr=3.0
    if x>0.5 then
      rho, pr = 1.0, 1.0
    end
    Er = pr/(1.4-1)
    return rho, 0, 0, 0, Er
  end
  
  q:set(initQ)
  qOld:copy(q)

  dt = 0.02
  tStart, tEnd = 0.0, 0.2
  tcurr = tStart
  while tcurr<=tEnd do
    Lucee.setCurrTime(tcurr)
    status, suggestedDt = hyper.update(tcurr+dt)
    qOld:copy(q)
    tcurr = tcurr + dt
  end
#+END_EXAMPLE

* October 3rd

  Should setPtr method be in the FieldItr class instead? I.e. that
  would prevent using an iterator with the incorrect field.

  Should there be another class GridField? This would store the grid
  information inside it in addition to being a field. Perhaps call it
  a StructGridField to distinguish it from possible future
  UnStructGridField?

  Creates a StructGridField class for fields that live on structured
  grids. When its writeToFile() method is called it writes both the
  field data and the grid.

  Created a dummy method set() that will (when completed) initialize
  the field using a Lua function. [Later] DONE!!

  A problem: what happens when a Lucee object goes out of scope in Lua
  and gets garbage collected, while another Lucee object still has a
  reference to it? Potential solution: reference count each object?
  Can this be done transparently without changing any Lucee classes?

  Another problem: should time be a global in a Lucee simulation? Most
  likely not.

* October 2nd

  Now completed the creation of FieldPtr and ConstFieldPtr from
  std::vector.

  Need to now allow direct creation of DataStruct without the
  intervention of factories. DONE!

  There is a significant problem with type-saftey for objects created
  in Lua and accessed in Lucee. The issue is that Lua stores the
  object as a void* which means that all type information is lost!
  Although Lua suggests to use the luaL_checkudata method, the problem
  with this in Lucee is a confusion between base class and derived
  class names. I.e. we wish to access base class pointers even when
  the Lua object is a derived object.
  
  One solution is to add *two* metatables: one named after the base
  class and the other named after the derived class. Then, the access
  method should first check for the derived class metatable and then
  the base class metatable. If neither are found it should throw an
  error. [Does this not mean there should only be a derived class
  metatable? Perhaps something better is needed.]

  Added a method to write Field. Need to improve this by putting this
  in Field class and (a) writing the grid in the same h5 file and (b)
  not writing the ghost cells.

* October 1st

  I have written code to convert FieldPtr and ConstFieldPtr to T* and
  const T* respectively. This has two issues: loss of information
  (length is lost) and access to the raw data pointer.

  Perhaps one idea would be to introduce new classes (ConstVecWrap,
  VecWrap) that stores the pointer and the length and that can be
  constructed from FieldPtr and ConstFieldPtr, in addition to a
  std::vector<>. Then, basic functions like flux calculators can have
  signature

#+BEGIN_EXAMPLE
  void flux(ConstVecWrap q, VecWrap flx);
#+END_EXAMPLE 

  Which can be used as
#+BEGIN_EXAMPLE
  std::vector<double> q, flx;
  // set q
  q[0] = 0.0; q[1] = 1.0;
  flux(q, flx);
#+END_EXAMPLE

  This would mean that the Wrap objects must be passed as values as
  references can not be created to temporary.

  WAIT: This is exactly what a FieldPtr is!! So just extend it to
  initialize in addition from std::vector<>. DONE!

* September 30th

  Added more methods to StructuredGridBase class for access from
  Lua. This is an easy but tedious job. However, the basic code is now
  in place. Some objects like Region etc will need to be put into a
  global module (like Lucee.Region {}) so they become available from
  Lua. This can be done later.

  Added getObject() method to LuaTable class. This allows fetching
  reference to Lucee objects stored in Lua tables.

  Made SolverIfc class available from Lua scripts. Now RTE solver
  works from the script. The advance() method needs to be called
  explicitly.

  Removed builData() and buildAlgorithms() methods from SolverIfc.

* September 29th

  The factory methods need to be removed. This will eliminate the
  confusion of registering a factory instead of the actual object
  itself.

  [Later] Removed registration of factory for Grid. To do this I
  simply call the grid factory from the grid class and use the
  assignment operator to construct the object.

  Added a write method to GridIfc class to write grid to hdf5
  file. Seems to work just fine. At this point it seems all basic code
  for making Lucee objects callable from Lua is in place. Next to add
  methods to the LuaTable class to get userdata from the readInput()
  method.

* September 25th

  Most code to make Lucee objects usable from Lua scripts is now
  complete. Testing is needed. Also, need to figure out how to fetch a
  user-data object from a table (i.e. LuaTable object). All need for
  getNew() should now be over. Then, I can remove the ObjCreator class
  from the system and cleanup.

  [Later] There is a problem with the meta-table name embedded in each
  object: i.e. the meta-table name is constructured using the typid of
  the derived class but often the PointerHolder::checkUserType()
  method is called with the base class type. Hence, there is a
  mis-match of typeid() and Lua refuses to run the code. For now, I
  have switched out the luaL_checkudata() method for the
  lua_touserdata() method. Perhaps dynamic casting is needed? [Oct 2:
  Dynamic casts will not work as the basic object is a void* and hence
  C++ has no way of determining the object type]

  One other major problem is the existence of the Factories: when a
  Lua object will be created, it will return a pointer to the factory
  and not the actual object itself. This means the calls are made to
  the factory. This needs to be fixed ASAP.

  Also, writing the Lua callable methods will become rather
  tedious. Perhaps I need to add some helper classes to make this
  easier?

  [Later] The solution to the Factory created objects problem is to
  have two different methods that make the Lua object from C++ code:
  the first applies to classes that support readInput() directly. The
  second applies to classes that are created from a Factory. The
  choice between these methods can be made using two classes, one
  speclized to any T and the other to GenericFactory<T>.

  Also, the method appendLuaCallableMethods() from the derived Factory
  class will need to call the constructed object's
  appendLuaCallableMethods().

* September 23rd

  One way to automatically run the top-level simulation (if it exists)
  is to get the simulation object from C++, check if it really is a
  derived class of SolverIfc, check if it has already been run, and if
  not, run it.

* September 21st

  Just some notes to keep track of things. First, documentation needs
  to be started *now* to ensure it does not get too late to
  document. Need to update the doxygen comments to add more details.

* September 13th

  The LuaModule class needs to be modified to have a map:

#+BEGIN_EXAMPLE
  std::map<std::string, std::vector<luaL_Reg> > refFuncs;
#+END_EXAMPLE 

  or a more complex data-structure. The key could be the derived class
  Id and the vector could be the list of functions to register. The
  derived class should add all the methods it needs to this list.

  When the ObjCreator class moduleRegister() method is called it
  should add, in addition to the methods already added, the base class
  exposed methods and register all these methods. It should create a
  unique meta-table per derived class in so these methods become
  available in a object oriented manner.

  The main method to create the derived class itself should be as it
  is now: i.e. the module name should be the base class ID while the
  creation method name should be derived class ID.

  This will impose a requirement on all Lua callable class to provide
  a static method names appendLuaCallableMethods() to the supplied
  list.

* September 12th

  Figured out how to wrap C++ objects using the current Lucee
  system. Essentially just small modifications to the ObjCreator and
  ObjRegistry classes was needed. This work is in a branch

  https://lucee.googlecode.com/svn/branches/lua-obj

  At this point I have two tasks (a) create two new classes
  corresponding to ObjCreator and ObjRegistry to make Lua objects from
  Lucee objects (I could also simply modify the existing two classes)
  (b) create some means of allowing both base classes and derived
  classes to register methods to operate on the Lua objects.

  The latter task seems much harder to handle in a uniform manner. One
  obvious way to do this would be expect static methods in derived and
  base classes that are always called when the registration
  happens. Of course, this means that these methods must always be
  provided for the system to compile. Even after this is resolved, I
  still need to think of how the call will actually occur. The
  simplest, but least elegant way would be for each class to provide a
  static wrapper method that gets called from Lua. Then, the class
  would do a cast and make the call. Perhaps there is no other way to
  do this.

  However, once this is done, Lucee will have a very powerful manner
  of working. Objects could be created, queried for debugging and
  complete simulations written using Lua.

  Some notes on how to get this to work:

  - Need to rename the ObjCreator class to something more
    meaningful. I.e. as this class adds the Lua call-backs and does
    not really "create" anything.

  - The getNew() method from the ObjCreator can go away as it no
    longer will be needed.

  - The name of the metatable must be combination of the base-class ID
    and the derived class ID. How to do this? This can be done by
    extending the LuaModule class. In this, add the derived class ID
    (store in a vector of strings) and a map of derived class ID to
    callable methods. Then, in the ObjCreator's registerModule method
    we can loop over this and register stuff. (Will this really work?)

* September 10th

  Wrapping a C struct in Lua is very easy. There could still be a
  problem with wrapping C++ classes, though. The issue is that at
  first sight it seems impossible to call the default ctor of the
  class while creating it. Need to figure this out.

  However, once done, getting direct access to Lucee object in Lua
  should be relatively easy task. The main thing is to make the object
  contruction a two-step process: in the first, we register the object
  as usual. In the second we add a method to Lua to call the getNew()
  method. This method will get called, the object will be passed the
  table to construct itself and the resulting data returned. Will need
  to be careful with resource handling.

  A global singleton object holding pointers to all DataStructs,
  Updaters, Grids etc will need to be made. This will allow the C++
  code to access these objects so as to use them when needed.

* September 8th

  After a long time I am getting back to Lucee. I wish to complete the
  system at least to a point where I can solve 1D hyperbolic
  equations. This should be in preparation for the PPPL interview at
  which I would like to present results (if possible) only from Lucee.

  A better way needs to be found than the "table-driven" approach. It
  will be a radical departure from both Facets and Warpx. One option
  would be to have a file like
#+BEGIN_EXAMPLE
  grid = Grid.RectCart1D {
    cells = {10},
    lower = {0.0},
    upper = {1.0},
  }

  q1 = DataStruct.Field1D {
    onGrid = grid,
    numComponents = 5,
    ghost = {1, 2},
  }

  initField = Updater.TXYZFieldSetter2D {
    func = Function.LuaTXYZ {
    numOut = 5,
    f = function (t, x, y, z)
    return 1, 2, 3, 4, 5
    end,
  }

  initField.update(0.0, outVars = {q1})
  q1.sync()
  q1.dump("output.h5")
#+END_EXAMPLE

  This may be a radical change in the way Lucee works, but perhaps
  easier than I think.

* July 9th

  Added TXYZFieldSetter updater. Tested from code. This updater sets
  the supplied array using the provided function.

  Also ensured that updaters are now recognized from input files.

* July 8th

  Added LinCombiner updater. Tested from code. From input file this
  should look like, for example
#+BEGIN_EXAMPLE
  grid = Grid.RectCartGrid2D {
    cells = {10, 20},
    lower = {0.0, 0.0},
    upper = {1.0, 1.0},
  },

  combo = Updater.LinCombiner2D {
    onGrid = "grid",
    coeffs = {0.5, 0.5},
  }
#+END_EXAMPLE

* July 3rd
  
  The next step is to add a Stepper base class. This should run
  specified updater using a time-stepping mode. The stepping mode
  should be provided by derived classes. For example: ConstantDt class
  should provide a constant time-stepping mode where the dt is
  specified.

* July 2nd

  (A few days) No work for a while.

  Added UpdaterIfc class to represent updaters in Lucee. Initially
  these were derived from SolverIfc but had to break this up and make
  UpdaterIfc its own base class.

  One key objective was to allow use of updaters directly from code
  rather than just input files. This was achieved by letting users
  create an updater in code, set the inp/out data structures, and call
  the update(t) method.

  Added FunctionIfc class. This allows the creation of function
  objects that provide a eval() method:
#+BEGIN_EXAMPLE
    std::vector<double> eval(const std::vector<double>& inp);
#+END_EXAMPLE
  The size of input and out vectors can be specified as ctor
  parameters. 

  Redid the LuaFunction class: renamed it LuaTXYZFunction and it now
  derives from FunctionIfc. The LuaTable class had to be expanded to
  allow for getting access to references to Lua functions. This allows
  creation of LuaTXYZFunction from input file blocks.

* June 17th

  (A few days). Now have Fields initialized from input files. Also
  added a LuaFunction class that allows wrapping a Lua function in
  C++.

  The LuaTable class had a major bug in which the Lua stack size kept
  growing. This caused a segfault on my new Mac. Wrote a set of macros
  to track stack size. Now the stack is exactly balanced in each call.

  One thing that Lucee needs is a general set of vector operators:
  div, grad and curl. These operators should work on body fitted grids
  and should preserve the discrete vector calculus identities. One way
  to do this is to implement the Support Operator Method (SOM) for the
  discrete vector calculus operators. This would allow a combination
  of these operators to construct, for example, a Navier-Stokes
  solver.

* June 5/6th

  Completed reading of grids from input files and writing them out to
  HDF5.

  Major work to create typeMap in the LuaTable class. This allows the
  implementation of the getNamesOfType() method needed in
  SolverAssembly.
  
* June 4th
  
  Added GridBase class, derived StructuredGridBase from it and created
  a "Grid" module and registered it into Lucee.

* June 1st

  Completed BodyFittedGridBase and RectCartGrid classes. Tested the
  methods. Also added default ctor in Vec3.

  Why not use Vec3 for coordinates and vectors? The answer is that
  fixed sized vectors of size 3 are simpler, and probably much faster.

* May 28th

  - Fixed getSubCompView with ghost indices.
  - Seems like that for getSubCompView() should really have its
    component indices always starting with index 0. (Now fixed)

* May 27th

  Added ghost indices to fields. A lot of work to fix. Still does not
  work with slicing and sub-component views.

* May 26th

  - Created a Vec3 class to store vectors in 3D space. In preparation
    for adding a body-fitted grid class.

  - Started on BodyFittedGrid. The idea is to have a base class called
    BodyFittedGridBase from which BodyFittedGrid and CartGrid will be
    derived.

* May 25th

  Back to working on Lucee after a long while. Added a SolverAssembly
  class that will serve as a general purpose solver to assemble a
  simulation using grids, data and updaters.

  Need to figure out a way to avoid specifying dimensions in the input
  file. Everything can be determined from the dimension of the grid.

  Example::
#+BEGIN_EXAMPLE
    simulation = Solver.Assembly {
      domain = Grid.CartGrid {
        lower = {0.0, 0.0},
	upper = {1.0, 2.0},
	cells = {10, 20},
      },

      q = DataStruct.Field { 
        onGrid = domain,	
	numComponents = 5,
	ghost = {1, 1},
      },

      qOld = DataStruct.Field { 
        onGrid = domain, 
	numComponents = 5
      },

      qMom = DataStructAlias.Field {
        target = q,
	componentRange = {1, 4},
      },

      init = Updater.InitField {
        onGrid = domain,
      },

      stepper = Stepper.ConstantDt {
        dt = 1.5e-3,
	initialize = {initQStep, initiQoldStep},

	initQStep = Step {
	  updater = init,
	  out = {q}
	},
	initQoldStep = Step {
	  updater = init,
	  out = {q}
	},

      },
    }
#+END_EXAMPLE

* April 2nd - 6th

  No work on Lucee. Need to get back on this and bring the RTE solver
  to a completion.

* April 1st

  Trying to figure out particular solutions at dummy nodes. Seems like
  a real mess.

* March 31th

  Started work on dummy-node inclusion. Not working or complete
  yet. However basic ideas are clear.

* March 26th, 27th, 28th, 29th, 30th

  No work on Lucee.

* March 25th

  - Added cases 4 and 5 to verification studies. Setting
    varpi=1.0-1e-8 works well for cases when varpi=1.0. All decimal
    places for irradiances are computed correctly for irradiances.

* March 24th.

  No work.

* March 23rd

  - Now writing out irradiances. Tested irradiance E_0 with Siewert
    benchmark paper. Are exactly correct to all significant digits.
  - Next need to impliment dummy-node-inclusion method to get
    radiances at ordinates with zero weight.

* March 22nd

  - Added code to compute irradiances. Not tested and irradiances not
    yet written to file.
  - Added innerProduct() method to Vector class. NOT TESTED. Too tired
    to do this tonight but must do this.

* March 21st

  - Fixed a bug in hasStrVec() and hasNumVec() methods of LuaTable
    class. Not enough tests or else this would be caught earlier.
  - Added basic code to compute irradiances. Not complete yet.

* March 20th

  - Added duplicate() method to Array class.
  - Added method to write an array to HDF5 file. One needs to be a bit
    careful here as HDF5 expects data in row-major order while the
    default array layout is column major order.
  - Now writing out the radiance data as a numMode x N array rather
    than a separate array per mode.

* March 19th

  - Added code to compute half-space solution. Not tested.
  - Thought of using dummy node inclusion method as an interpolation
    technique for the RTE. Seems a better technique than the
    source-function integration method of Siwert.

* March 18

  - Now writing out RteHomogeneousSlab data as HDF5 files.
  - Started on benchmarking exercise with Garcia and Siewert paper.

* March 17

  - Debugged RteHomogeneousSlab. It now works.
  - Added HDF5 I/O classes to Lucee. Do not work for reading Vec
    attributes.

* March 15, 16

  - Now RteHomogeneousSlab solver basic algorithm is complete. Data
    yet to be written out. Now sure if to just do it in HDF5 or do
    some intermediate step before that.
  - Still need to figure out how to compute the irradiances.

* March 14
  
  - Added getView() method to matrix class.
  - Lot more work on RTE slab solver. Now close to being done.

* March 12, 13th

  - Added a document RteHomogeneousSlab.tex that describes the
    algorithm step by step.
  - Added scaleRows() and scaleCols() methods to the Matrix class.
  - More work on RTE solver.

* March 11th

  - Added phase function classes: HG phase function and phase function
    based on expansion coefficients.

* March 10th

  - Added LcMathLib file with math functions. Added gauleg() method.
  - Removed FcSimulation files. Now main() directly creates the
    SolverIfc class and drives.
  - Now have GSL properly linked. Some more familiarity with cmake is
    needed to get this figured out properly.

* March 9th

  - Added basic methods in LuaTable. Tested these. Next to implement
    the vector forms of these methods. Also, need to be careful about
    not polluting the stack.
  - All methos in LuaTable now implemented. Need to think about how to
    get and evaluate functions in Lua.
  - Module registration system needed re-work. Now seems to work.

* March 8th

  - Figured out way to use Lua tables. The basic idea it to use the
    luaL_ref() method to get a reference to the internal Lua table
    object. This can then be used to implement a persistent table
    access class.
  - Added a class LcLuaTable to represent tables. Not completed.

* March 5th, 6th and 7th

  No work on Lucee

* March 4th

  - Added ObjRegistry and ObjCreator classes. These were simply copied
    over from a old Lucee tag.

* March 3rd 2010

  - More playing around with Lua and object registration/creation
    process. Now figured out how to get global values and from tables,
    add new C call-back methods and register new modules.
  - Added lucee executable and command-line parsing, Simulation class.

* March 2nd 2010

  - Made notes on ideas for solvers Lucee. Added a class SolverIfc
    that defines the basic interface supported by all Lucee
    solvers. This will evolve as features are added, in particular
    when going parallel.
  - Starting to get better hold of reading table data out of LUA. Made
    LUA not use dynamic libraries.

* March 1st 2010

  - Fixed the getSubCompView() method. The solution is to get rid of
    the getLowIndex() method and use getIndex() method with 0 as the
    final index. This now allows selection of a range of components in
    a field to create a new field.
  - Renamed getGenIndex() -> genIndex().
  - Completed the solve() method in LcLinAlgebra. Unlike other
    linear-algebra methods, this one modifies the input matrix and
    also expects the matrices to be contiguous.

* Feb 28th 2010

  - Now getView() method works in LcField. The selection of
    sub-components of the field object seems rather tricky.
  - Discovered problem: when chaging start index both ai[0] and
    start[] are modified such that the modfied and new indexer return
    the same linear index. That is not what we want in selecting the
    sub-components. Instead, we want to just change ai[0] by sc so
    that the correct reference to the sc component is returned on
    passing 0 in the sub-comp-view field. Not yet fixed.

* Feb 27th 2010

  - Starting to add ability to find external libraries. First one: GSL
    for RTE work.

* Feb 26th 2010

  - Added getRow() and getCol() methods to Matrix class. Also added
    the ability to create Vector object from a Array<1, T>
    object. This allows the getRow() and getCol() methods to return
    Vector objects.

* Feb 25th 2010

  - To support deflating of Array the INDEXER template parameter had
    to be made a class template. Now, the Array declaration looks
    mighty ugly:
#+BEGIN_EXAMPLE
    template <unsigned NDIM, typename T, template <unsigned> class INDEXER  = Lucee::RowMajorIndexer>
    class Array;
#+END_EXAMPLE
    Further, Array<NDIM> class needs to friend itself to access private
    stuff from Array<RDIM>, where NDIM != RDIM. This horror looks
    like:
#+BEGIN_EXAMPLE
    template <unsigned RDIM, typename TT, template <unsigned> class IINDEXER> friend class Array;
#+END_EXAMPLE
  - Added deflate() methods to both indexer classes and to the array
    class. Seems to work just fine.
  - Derived classes of Array will need to provide their own deflate
    methods. In particular, Matrix class should support getting a row
    or a column. What should Field do?

* Feb 24th 2010

  - Completed Row and Col major sequencers.
  - Added a typedef to Row and Col indexers to allow creation of
    proper sequencers. This allows arrays and derived classes to use
    the correct indexer/sequencer pair.

* Feb 23rd 2010

  - Started work on row-major sequencers. Not complete yet.
  - Indexers may need to return associated sequencers.

* Feb 22nd 2010

  - Discovered a bug in indexers. It seems indexer hierachy needs to
    be rethought. The basic indexer class (common to linear indexing
    mechanisms) needs to be abstracted out into a base class. Then,
    the row and column major indexers will inhert from this base class
    and provide the coefficients in the linear mapping. It is not so
    clear what the system should be for non-linear mapping.
  - Completely redid the indexing system. Introduced a LinIndexer
    class from which the RowMajor and ColMajor indexer classes
    derive. Now should allow for slicing and deflating of arrays.

* Feb 21st 2010

  - Hooked in ctests into Lucee. Now one can run all the tests with
    one commmand in the top-level build directory, either 'ctest' or
    'make tests'.
  - Finished FieldItr class. This allows the following:
#+BEGIN_EXAMPLE
    int lo[2], up[2];
    Lucee::Box<2, int> rgn(lo, up);
    Lucee::Field<2, double> elcFld(rgn, 3);

    Lucee::FieldPtr<2> ptr = eclFld.createPtr();
    elcFld.setPtr(ptr, 5, 5);
    
    ptr[0] = 1.0;
    ptr[1] = 2.0;
    ptr[2] = 3.0;
#+END_EXAMPLE
    I.e, using FieldPtr one can access/modify the elements at a
    location in the field.
  - Finished ConstFieldPtr class. Same semantics as FieldPtr except
    that is allows pointing to constant Field objects.
  - Finished the getSlice() method in Array object. How do slices of
    derived classes work? Probably need a covariante return
    thunk. Also, this brought up the issue of being able to assign all
    the elements of a sliced-array.
