# -*- org -*-

* May 24th

  Added a method writeToTxt that allows writing data-structs to a
  plain text file. This allows easy reading into Matplotlib. The data
  in each cell is written on one line. The first NDIM entries are the
  coordinates and the next numComponent entries are the values stored
  in the field at that location.

  Implemented characteristic limiters to MUSCL/Hancock algorithm. The
  results still look very crappy. FIXED!!

  Turns out that the problem was that I was not using the estimated
  values at the edge but using the previous time-step solution. Also,
  the other problem was with the incorrect indexing. The first layer
  of ghost cells need slopes and predicted values computed to ensure
  that the first and last cell in the domain are updated correctly.

* May 23rd

  Implemented Hancock-MUSCL algorithm as described by van
  Leer. Boundary conditions really, really need to be implemented now.

  Characteristic limiters are required. Add a method to project a
  vector on left eigenvectors and back to right eigenvectors.

* April 10th

  Although basic unstructured grid data is stored in flat arrays the
  wrapper classes to get OO access to the data and incidence lists are
  becoming complicated. Need to relook at this more carefully to make
  a cleaner solution. At the least, each of the grid element classes
  needs to be put into its own file to make the LcUnstructGridElems
  file less messed up. Then, the iterator classes inside UnstructGrid
  need to be finished.

  One option is to add methods to the UnstructGeometry class to allow
  insertion/access of data using methods without direct access to
  memory. The grid and creator classes would still be friends to allow
  easier creation of element wrappers.

* April 8th

  Really good progress on unstructured grids. Now have basic code to
  read mesh from GMV files, write to HDF5 and also a start on iterator
  classes. The next step is to write incidence iterators and then
  construct the incidence lists needed.

* April 1st

  Started work on unstructured grids. The basic idea here is to store
  connections in a sparse format and minimum required geometry. In the
  bare-minimum case only nodal coordinates are stored and cell->node
  mapping is stored.

  The connectivity (d->dprime) is stored in 2 arrays: an offsets array
  and an index array. The n-th element of dimension 'd' is connected
  to the elements index[j], where offset[n]<=j<offset[n+1]. The reason
  to have the offset array is that allows fast access to the
  connections in case the mesh is composed of mixed type of cells
  (tri/quad or tet/hex/pyramids).

  The other connectivies (besides ndim->0) is computed on demand when
  needed the first time.

  A set of wrapper objects need to be written that put a OO interface
  on top of these raw data. For example, iterators need to be written
  to walk over all elements of a specified dimension. Recursive
  iterators should be constructible, i.e., it should be possible, for
  example, to iterate over all cells, the faces connected to each cell
  and the edge connected to each face (in a nested loop, for example)

  The basic data is stored in flat arrays for several reasons. First,
  the topology is separated from the geometry and second, flat arrays
  allow straightforward usage on restrictive architectures like GPUs.

** Notes on differential operators on grids

   Two types of differential operators need to be implemented on
   grids: explicit and implicit. The explicit operators can directly
   difference the discrete fields. However, the implicit operators
   need to use some sort of expression templates to delay evaluation
   till required. When the complete expression is created, the
   implicit expression template is then used to fill up a matrix
   (usually) that is then used to perform the implicit update.

* March 29th 

  The problem seems with the multiple indirections required to get
  hold of values in Lucee::Array class. This is not such a big deal if
  the operations are more expensive than the array fetch. However,
  more efficient basic operators (+, *, /, etc as found in valarray)
  are needed.

  After some work the performance of Lucee::Vector seems a bit
  better. It seems that the valarray classes are far more efficient on
  the newer gcc than the one on the home machine (gcc 4.2.1).

  Played around with expression templates from the article
  "Disambiguated glomable expression templates". I think it will be
  beneficial to use implement this technique in Lucee. Then, one can
  imagine a variety of matrix class (symmetric and diagonal are
  needed) that can make the RTE solvers very compact and succinct: an
  almost direct transcription from Siewert's papers. Eventually, I
  want to implement inhomogeneous algorithms for both polarized and
  non-polarized cases.

  Should run Shark on wave-propagation solvers.

*** TODO Figure out a way to find Lapack/Blas on Linux with CMake

    Then make Lucee work on Linux.

* March 28th

  First, Mercurial is giving a lot of trouble. Perhaps the move from
  svn was not worth it.

  Turns out that the Lucee::Array class design is basically
  flawed. The problem is with the underlying store of data as T*
  degrades performace. Seems like I need to move to some sort of
  valarray as an underlying representation of the data.

* March 2nd

  Move lucee to mercurial on bitbucket. The complete history is moved
  over. Easy to migrate and now will delete the googlecode version of
  the code.

* February 18th

  I really need to get back to productive scientific research. What is
  this nonsense amount of time spent on meeting and planning for the
  next one? How can any productive work be done?

  For Lucee, in order of priority: (a) complete hyperbolic solver,
  test with Euler equations, (b) hook in the documentation sytem, (c)
  write documentation.

  Work on the 10-moment stuff. How about design of a vacuum algorithm
  for use in jets? Divergence preserving collocated Maxwell equation
  solver?

* February 4th

  Need to get back to this. One of the first things to do is to clean
  up the documentation and start working on documenting Lua object
  constructors and methods. Integration of the TableDescription class
  into the readInput() methods needs to be completed. Not sure how to
  do this yet, but it is important to get this finished.

* January 22nd

  Completed VectorDescription class and hooked into TableDescription
  class. Next step is to hook the whole thing into the Lua table-based
  creation system.

* January 19th

  Added validity tests in ValueDescription class. Wrote tests for
  values in TableDescription class. Works just fine. Next, need to the
  same for VectorDescription class.

  How to integrate this into the class system to make it work with
  readInput() method is not yet clear.

* January 18th

  Created first-cut implementation of ValueDescription and
  VectorDescription classes. These are incorporated into
  TableDescription class. Each table can have a set of values and
  vectors (for now). Perhpas more comprehensive feature in the future
  will be to add additional elements to TableDescription.

  Next step is to set setVar() variables from Lua table. Other
  elements in the table should be ignored. This can then be chained
  up-the-derivation tree to setup the complete object.

* January 17th

  Finally, I think the transverse solvers are worked out in my
  head. The essential point is that there are two coordinate systems
  for these: the normal coordinate system and the transverse
  coordinate system. Call these RN and RT.

  Then, we have ql, qr local to RN and apdq (say) in RT
  coordinates. So, compute Roe average from local qr and ql. Rotate
  momentum back to global and then to RT. Then, perform the split in
  RT. Rotate bpapdq and bmapdq to global from RT. Then compute
  updates.

  An efficient way to do this is to store the Roe averages in global
  coordinates in an array. Then, only rotation of Roe average to RT is
  needed and the complete Roe averaging procedure is not needed. For
  this, the waves() interface will need to be extended to allow the
  HyperEquation class to set extra data which the wave updater
  stores. For example, the HyperEquation could tell the wave updater
  how much extra data it needs to store per call to wave() and the
  updater then allocates and stores this.

* January 16th

  Need to start work on Lucee again. Need to really ramp up rate at
  which work is being done to get to a usable system by the time PPPL
  move happens.

  - Boundary condition updaters needs to be written.
    
  - Is onGrid really needed for updaters? Each array needs to carry
    its own grid and hence this is not needed. In fact, it can cause
    problems when arrays are being used to update across grids.

  - The WavePropagationUpdater needs to be tested. First Maxwell
    equations and then Euler equations.
  
  - Transverse solvers needs to be completed. This needs to be looked
    over very carefully to ensure that the code is correct.

  - Some thought needs to be given on what efficient methods to
    implemented. Perhaps PPM? 

  - How to couple something like wave with FDTD Maxwell solver?

  - Documentation needs to be started/completed. API documentation
    needs to be expanded (doxygen) and Lua script documentation needs
    to be started.

  - How to automate Lua table documentation? C++ class? Lua tables
    describing data? XML files?

  - Documentation needs to be thought off also in terms of simulation
    templates. I.e. consider a template that describes RTE solver or
    FDTD solver. The script could be complex but only a few inputs
    need to be changed for a new simulation. How to abstract this to
    make the usage of the code easier?

  - How to bring in MPI to the code? Same as warpx/facets? Something
    different?

* January 8th

  Created notes for eigensystem of Euler equations. This is not such a
  trivial matter and needs careful analysis to make sure the Riemann
  problem needed in wave propagation scheme actually is correct.

  Next, need to make notes on wave propagation scheme, specially
  giving a careful treatment of transverse solvers.

  Also, eigensystem for Maxwell equations need to be written up. And
  the details of the FDTD method. In short, everything that can be a
  production algorithm needs to be completely documented so someone
  can understand and cross-check the code.

  How about computing a relaxation system for the 10-moment equations?

* January 7th

  For EM fields the concept of dual meshes is very important due to
  the curl appearing in both Maxwell equations. Hence, it may be
  important to create four spaces: NODAL, CELL-CENTER, EDGE and
  FACE. These would allow storing of vector fields on these
  spaces. The NODAL and CELL-CENTER vector fields would be collacated,
  while the EDGE and FACE vector fields would be staggered. Then, one
  can imagine developing a series of vector opertors that take a field
  from one space to another space. These would include div, curl, grad
  and interpolation operators.

* January 6th

  Figured out the correct way to do the curl updates. The point is
  that there are two updaters needed: EdgeFaceCurlUpdater and
  FaceEdgeCurlUpdater. The first computes the curl of a face-centered
  field and puts it into an edge centered field, and visa-versa. These
  two can be used to create a simulation that solves the Maxwell
  equations using FDTD method.

  The next major work that needs to be done is creation of boundary
  condition updaters. These need to be thought carefully to create
  easy and powerful way to apply BCs.

  An automatic method needs to be developed to make the Lua table
  constructors self-documenting. One way would be for a class to call
  a checkAndReadTable() method that would be called from readInput()
  method that would set variables in the class. This way a class may
  use this facility or may not, depending on how much work the
  developer wants to put into the table validation. If a class uses
  this facility, then the documentation for that class could be
  generated automatically and input safety achieved.

* January 5th

  Completed curl updater. Not tested yet. Used loop over direction
  combined with deflate() method to perform updates. Perhaps not the
  most efficient way to do this, but probably good enough for now.

  Need to check for time-step restriction using CFL condition. Perhaps
  need to put CFL number in input file?

  [Later] This updater is NOT CORRECT. The issue is that the x, y and
  z components are not indexed in a self-consistent manner. I.e. the
  mesh and fields looks like

             i-1                      i                      i+1
  |-----------*-----------|-----------*-----------|-----------*-----------|
  Bx(i-1)    Ex(i-1)      Bx(i)       Ex(i)       Bx(i+1)     Ex(i+1)
  Ey(i-1)    By(i-1)      Ey(i)       By(i)       Ey(i+1)     By(i+1)
  Ez(i-1)    Bz(i-1)      Ez(i)       Bz(i)       Ez(i+1)     Bz(i+1)

  Hence the update formula for By is

  dBy(i)/dt = 1/dx*[Ez(i+1)-Ez(i)]

  while for Ez we have

  dEz(i)/dt = 1/dx*[By(i)-By(i-1)]


  Hence, it seems there should be two updaters: EdgeFaceCurlUpdater
  and FaceEdgeCurlUpdater. The first updates a edge-centered field
  from curl of a face-centered field (in 3D) while the second updates
  a face-centered field from curl of a edge-centered field (in 3D).

  Deleted SolverAssembly class from system. This is no longer needed
  as all simulations will be driven from Lua scripts.

  Should add a PhysConstants module to Lucee so user can do things
  like PhysConstants.SpeedOfLight, PhysConstants.ElectronMass, etc.

* January 1st 2011

  Made a new project to hold build script for lucee and
  dependencies. It now compiles cmake, hdf5 and gsl and then builds
  lucee. Had to add an install target to lucee to install built binary
  into install location.

  To compile with release mode do

  cmake -DCMAKE_BUILD_TYPE=Release

  Debug can also appear here to build with debug flags.

  Figured out an error in WarpX transverse solvers. Essentially need
  to follow 2006 JCP paper carefully, specially Eq 55.

* December 30th

  Fixed slow-down problem with creation of matrices. For this now the
  rotation function in HyperEquation take double* instead of FieldPtr.

  Created a new branch

  https://lucee.googlecode.com/svn/branches/tx-cmake

  to convert to using TX CMake system. Also created a new project og
  Google code to hold the packages needed to build Lucee.

  https://lucee-packages.googlecode.com/svn/trunk

  This uses the TX bilder system to build (for now) HDF5 and
  GSL. Later will add more packages as needed.

  Need to create a lucee-build-all project to hold the script that
  builds lucee and all needed dependencies.

* December 29th

  To get closer to a usable system (a) boundary conditions (b)
  adaptive time-stepping and (c) transverse solvers need to be
  implemented. The task (b) needs to be done in Lua, of course.

  Adding rotations is significantly slowing down the system. In
  particular the rotation of the waves is horribly slow. One option is
  to instead copy data back and forth. Probably faster than all the
  object creation that is happening now.

* December 27th

  Need to figure out the transverse terms for
  WavePropagationUpdater. This need not be the full 3D transverse
  terms but just the 2D terms may be good enough for now. Of course,
  this needs to be done in a direction independent manner.

  Turns out that directional splitting is required to get proper
  advection in 2D. Otherwise the pulse is highly distored. In fact,
  for unsplit schemes the transverse terms must be included to get the
  proper un-distored solution. This essentially indicates that all
  transverse terms need to be included in 2D/3D to get accurate
  solutions.

  Example of a description

#+BEGIN_EXAMPLE
  td = this->getTableDescription();

  td.addObject("equation")
    .setHelp("Equation to solve. Should be a 'HyperEquation' object")
    .setVar(&eqn);

  std::vector<double> defDirs(NDIM);
  td.addOptionalVecTrait<double>("updateDirections", defDirs)
    .setHelp("Directions to update")
    .addOption(0)
    .addOption(1)
    .addOption(2)
    .setVar(&updateDirs);

  td.addTrait<double>("cfl")
    .setHelp("CFL number to use")
    .min(0.0)
    .max(1.0)
    .setVar(&cfl);

  td.addTrait<double>("cflm")
    .setHelp("Maximum CFL number. Should be slightly larger than 'cfl'")
    .min(0.0)
    .max(1.0)
    .setCheck(&checkCflm)
    .setVar(&cflm);

  td.addOptionalTrait<std::string>("limiter", "no-limiter")
    .setHelp("Limiter to apply")
    .addOption("no-limiter")
    .addOption("min-mod")
    .addOption("superbee")
    .addOption("van-leer")
    .addOption("monotonized-centered")
    .addOption("beam-warming")
    .setVar(&limiter);
#+END_EXAMPLE

* December 26th

  Found a bug in WavePropagationUpdater in which apdq and amdq were
  swapped. Works for 1D advection problem. Need to verify second order
  convergence and then test with Euler equations.

  In 2D the y-direction propagation of a pulse is more diffuse that
  the x-direction propagation. Very, very strange. [Later: Found the
  bug! The issue was that the waves, speeds etc are stored in 1D
  arrays while a 2D indexer was being used to set the pointers. Fix
  was to simply use the 1D index to set the pointers. Next to test and
  verify the order and accuracy.]

  How to make table for a block self-describing? One way: create Lua
  table describing the input. For example
#+BEGIN_EXAMPLE
    advDoc = HyperEquation.Advection {
      help = "Linear advection equation",
      speeds = NumVec {
        optional = false,
	size = 3,
	help = "Advection speed in each direction."
      },
    }
#+END_EXAMPLE
  One other option is to do this programmatically.
#+BEGIN_EXAMPLE
    void declareTable() 
    {
      Base::declareTable();
      TableDescription& td = this->getTableDescription();
      td.addNumVec("speeds")
        .setHelp("List of advection speeds in each direction")
	.setMinSize(3)
	.setMaxSize(3);
        .setVar(&speeds);
      td.addString("verbosity")
        .setHelp("Verbosity for console output")
	.addOption("debug")
	.addOption("info")
	.addOption("warning")
	.setVar(&verbosity);
    }
#+END_EXAMPLE

  What are features of a self-describing table? Each table contains
  "traits" (following Enthought) and other tables. Hence recursive
  definition is needed.

  - There are four types of traits: string, number, and vectors of
    these.

  - Each trait can be optional or required.
    
  - Optional traits must have a default values.

  - Each trait (or each element in a vector trait) can take values in
    a range: unbound, one from a set, or inside a range (for numbers).

  - Number of entries in a vector trait can be fixed or unbound.

  - A trait may be present only if another trait is present and/or has
    a particular value. This can be handled in a general way or just
    be restricted to testing for a single one. For example, one can
    imagine constructing a system that checks for a trait and its
    value and then combine these using logicals.

  - A table may be present only if a trait is present or has a
    particular value. Ditto as the previous point.

  A good start would be to code up only the first 4 and leave the
  if-cases to later.

* December 25th

  Added RectCoordSys class. Added derived class AlignedRectCoordSys
  that represents rectangular coordinate system obtained from a
  90-degree rotation. The RectCoordSys has two methods,
  rotateVecToLocal() and rotateVecToGlobal() that rotate vectors from
  and to global frame.

  Make the methods in HyperEquation be pure virtual. Otherwise missing
  functions are not caught at compile time.

  Completed WavePropagationUpdater. Does not yet work.

* December 24th

  More work on WavePropagationUpdater. Nearly completed. Once
  transverse terms are added the localRgn box may need to be extended
  to give effects of corner cells on the first row of cells.

  Should add a numerical flux function to each equation system. Then,
  let the equation system decide which flux to use.

  Perhaps it is important to introduce direction in the HyperEquation
  class. Otherwise non-isotropic systems can not be simulated. One
  option would be to introduce a RectCoordSys class that represents a
  coordinate system as three ortogonal unit vectors. This could be
  then passed to HyperEquation class to represent direction. [Done]

* December 19th

  Add a rotation class to Lucee. This will allow doing 2D and 3D
  problems. Also, add a vector to WavePropagationUpdater to indicate
  which directions to update. This will allow doing time-split
  algorithms from the input file by carefully combining them in the
  Lua script.

  How to do transverse terms in the correct way?

  Move the test updaters to new 'proto' directory.

* December 18th

  Added and tested duplicate() method to Field class. Now duplicates
  can be created from Lua script. Should open up the way to adpative
  time-stepping.

* December 16th

  Now can create a matrix from a raw pointer.

  PPPL may actually happen! In this case I need to start sprucing up
  lucee by documenting it in detail, specially its input file
  scripting format.

  There is no need for the modifications to the directional
  sequencer. Added a new function deflate() to the Region class to
  allow creation of a box with shape 1 in a specified direction.

   The class Updater should be renamed to something else. Perhaps
   Algorithm?

* December 12th

  - Need to modify the directional sequencer. This should work something
    like the following.
#+BEGIN_EXAMPLE
      DirSequencer<2> seq(rgn, dir);
      while (seq.step())
      {
        while (seq.sweep())
	{
          seq.fillWithIndex(idx);
	  // do something at idx
	}
      }
#+END_EXAMPLE

  - Added WavePropagationUpdater. This is templated over
    dimension. Still not complete, but should be easy. DirSequencer
    needs to be modified as described above.

  - How to create a field of matrices? Perhaps create a matrix by
    reusing the memory in a FieldPtr? Once this is done, then Fields
    can be created in the WavePropagationUpdater to store the various
    needed quantities.

  - For allowing for adaptive time-stepping, duplicate() method needs
    to be added to the derived classed of Array.

* December 11th

  - Added directional sequencer. This does two things: first, it
    allows sweeping a region in a specified direction. Second, it
    allows getting indices from a stencil. For example, consider a 2D
    region. We can perform X-sweeps or Y-sweeps. DirSequencer allows
    this.

  - Now error messages from tests are being put into a different
    file. This means only PASSED/FAILED message is printed from a unit
    test and it there are FAILED tests they go into a different file.

   Do I need to add directions back to flux/waves etc methods in
   hyperbolic equations? For example: in wave3D how to do transvere
   corrections? One needs to split X direction fluctuations into Y and
   Z direction fluctuations.

   What to do about rotations?

   A note on FieldPtrs: FieldPtrs can be sent to const
   ConstFieldPtr. Std::vector can be converted to FieldPtr or
   ConstFieldPtr. FieldPtr of given size can be created.

* December 2nd

  Black box testing can only uncover bugs but never prove that there
  are none. To ensure that bugs do not exist one needs to examine the
  structure of the algorithm and prove, mathematically, that it is
  correct, i.e. does what it promises.

  How do we create computational physics algorithms that can be
  trusted by construction?

  In brief the essential idea is: if you select the correct
  mathematical model and create a provably correct algorithm, then the
  steps of verification and validation are not needed, or just a
  pleasant conformation of what you already built into the system. Or,
  even more briefly, lets get it right in the first place.

  How can such a proof-based method be applied to computational
  physics? There are several challenges. First, we need to ensure that
  the chosen mathematical equations describe the physical system to be
  modelled with sufficient detail. This is impossible in general and
  approximations always need to be made. The degree to which these
  approximations affect the physical realism of the model is hard to
  determine and, ultimately, direct comparisons with experimental
  observations must be made. [Scientific Conception of the World]
  Second, once the mathematical equations are selected, a method to
  solve them needs to be developed.

  To select an accurate mathematical model an a priori approach is
  needed. The tradition "validation" step of comparing computational
  results afterwards to experiments, no matter how many, is not
  sufficient to prove that the mathematical model chosen is
  correct. What is needed is a clear understanding of the
  approximations made and if those are appropriate for representing
  the physical system being modeled. For example, often, if a system
  of equations is complex, simplifying assumptions of length and
  time-scales are made. However, although these approximations may be
  valid on a global scale, they are not valid locally, specially in
  regions where spatial and/or temporal gradients of solutions can be
  of the same order as the ignored scales.

  As a first step we can ignore the complexities of selecting an
  accurate mathematical model and focus on developing a provably
  correct algorithm.

  Remark 1: Is this not just the standard "verification" analysis? At
  first sight it seems like it, however, the distinction made in the
  first paragraph holds between verification and what is being
  proposed here. I.e. verification, as it is a post-algorithm and
  implementation step, can only uncover bugs but not prove they do not
  exist. Here, an analysis is being made on what it takes to construct
  a provably correct algorithm. It need not even be implemented [End
  remark]

  Remark 2: Is this not what all numerical scheme developers do?
  I.e. do they not show that their scheme converges, has so-and-so
  order? I submit that this process is only the first step. Even if
  the scheme converges with some order, it is not clear if it actually
  preserves the mathematical properties of the equation system. [End
  remark]

  What is being proposed here is the following. A scheme must solve
  the mathematical equations accurately, i.e. the scheme must provably
  converge to the correct solution in the appropriate limit. However,
  this is not enough. If the mathematical equations have certain
  properties, it must be proved that the scheme satisfies those
  properties. The larger the set of properties the scheme can be
  proved to satisfy, the greater the confidence in having developed a
  correct scheme. Note that this step does not actually require the
  implementation of the scheme in executable code, but only a
  sufficient knowledge of the mathematical properties of the system
  being solved and certain dexterity in manipulating the formulas
  involved in the scheme.

  What about actual implementation? For the scheme to be useful an
  implementation must be constructed. This step is fraught with
  difficulties. First, although our scheme may satisfy a broad variety
  of properties, its implementation is not guaranteed to automatically
  inherit this. This is due to the gap between a programming language
  and the language in which mathematical manipulations are done. A
  reason for the gap is the lack of formalization of the manipulations
  needed in the proofs. [Descartes calculating machine]. This gap will
  not close anytime soon. What is required is a new approach in which
  the scheme can be expressed directly, proofs performed (manually
  would be good enough) and transformed into executable code.

  Remark: The construction of a scheme is not unique: i.e. several
  schemes can be constructed for the same mathematical model. If each
  of these schemes is proved to be correct, then the one with the most
  efficient implementation can be selected. [End remark]

  So the question comes up: given the state of art, what programming
  techniques to adopt to ensure, as far as possible that the
  implementation is faithful to the scheme?

* November 8th

  Field and array classes need to be tested with the alias-ed
  fields. Aliases don't always seem to work, for some reason.

  Turns out that the Field::getSubCompView() method is not returning
  the correct sub-array. The base class methods in Array do not work
  correctly with sliced fields. This is a very important bug to fix
  ASAP. A clue: when using a sliced subComView field one does, for
  example, ez(i,j,0). However, the base class code actually uses the
  index ez(i,j,-2), in case ez points to the 3rd component of a
  3-component field.

  Big fixed! The solution is to reset the indexer and array start
  indices separately. This makes the getSubCompView a very tricky
  method to implement, but it looks likes the only way it can be done.

* November 7th

  Completed alias method for fields. This was relatively simple. Also
  added divergence operator to the structured grid field. Presently
  only works on rectangular grids.

  In the 2D TM Maxwell solver, the boundary conditions need to be
  figured out for the psi (correction) potential.

  Need to add BC updaters.

  Lucee is turning into a mixed OO and procedural system. Which is
  good as not everything needs to be an updater and this simplifies
  the input file code enormously. No endless writing of updater
  anymore.

* November 6th

  Completed TM Maxwell solver in 2D. This is to test ideas on how to
  conserve divergence errors in Maxwell equations.

  Need to write an alias function.

* October 31st

  Numerical flux class needs to be defined. The interface method
  should have the following interface.
#+BEGIN_EXAMPLE
    flux(ql, qr, fl, fr, sl, sr)
#+END_EXAMPLE
  where ql, qr are left/right conserved variables, fl, fr are
  left/right fluxes and sl, sr and left/right speeds.

* October 13th

  Probably should switch to Tech-X CMake system. Need to design the
  basic hyperbolic equation class. The solver should be numerical flux
  based and not wave based. This allows flexibility as the wave
  numerical fluxe can then be used in other schemes like MUSCL, DG
  etc. Somehow, when using wave propagation scheme the system should
  use the wave/fluctuation form of the update formula. The schemes
  should be dimensionally independent, i.e. work in 1D, 2D and 3D and
  on body fitted grids. Hence, one set of updaters should be enough
  for all structured grids.

  In the future I may wish to use unstructured grids.
  
  For documentation I should start using Spinx more extensively than
  now. Each piece needs to be documented carefully. The RTE solver
  needs to be documented and can perhaps serve as a template for other
  documents. GUI/Mouse driven systems like LyX or TeXMac do not work
  documentsfor me.

* October 10th

  Why is a PointerHolder class needed. One can simply store the object
  pointer itself and register the deletion class. ANS: It is needed
  because the new() method can be called after the pointer holder is
  allocated.

  Added a class LuaObjTypeId. This checks type of the object by
  casting to PointerHolder<BasicObj> and getting the stored ID
  strings.

* October 8th

  Working on wrapping Updater in Lua. Completed this. Now updaters can
  be called from Lua. The setIn() and setOut() methods must be called
  before the advance() method is called. Advance() returns a status
  and a suggested time-step. One issue is that the input and output
  types are not type-checked. This may be impossible in the present
  system as the type information is lost in putting stuff into Lua and
  getting it back (Lua stores void* to an object). One option would be
  store the typeid of each created object in the ObjRegistry
  class. Then, this could be queried when needed to ensure type
  saftey.

  Need to start documenting the Lua API.

* October 4th

  Added methods copy() and clear() to Field class. This allows copying
  from a field and setting all field values to given number.

  Also found a nasty bug in the RectCartGrid which was returning the
  incorrect centriod coordinates. Shows need to for more careful
  testing: essentially the getCentriod() method was assuming lower
  bounds of 0.0 for all grids irrespective of actual lower bounds.

  Added accumulate() method to Field and Array classes. This now
  completes basic operations of fields and makes them available from
  Lua, allowing for writing more complex algorithms.

  Should I rename Updater -> Algorithm? Seems like a more natural name
  than updater. One issue is what to do with time? Perhaps the
  simulation time needs to become a global? Not sure what to do yet.
#+BEGIN_EXAMPLE
  grid = Grid.RectCart1D { 
    lower = {0.0}, upper = {1.0}, cells = {100}
  }

  q = DataStruct.Field1D {
    onGrid = grid, numComponents = 5, ghost = {2, 2}
  }

  qOld = DataStruct.Field1D {
    onGrid = grid, numComponents = 5, ghost = {2, 2}
  }

  function initQ(x, y, z)
    local rho, pr=3.0
    if x>0.5 then
      rho, pr = 1.0, 1.0
    end
    Er = pr/(1.4-1)
    return rho, 0, 0, 0, Er
  end
  
  q:set(initQ)
  qOld:copy(q)

  dt = 0.02
  tStart, tEnd = 0.0, 0.2
  tcurr = tStart
  while tcurr<=tEnd do
    Lucee.setCurrTime(tcurr)
    status, suggestedDt = hyper.update(tcurr+dt)
    qOld:copy(q)
    tcurr = tcurr + dt
  end
#+END_EXAMPLE

* October 3rd

  Should setPtr method be in the FieldItr class instead? I.e. that
  would prevent using an iterator with the incorrect field.

  Should there be another class GridField? This would store the grid
  information inside it in addition to being a field. Perhaps call it
  a StructGridField to distinguish it from possible future
  UnStructGridField?

  Creates a StructGridField class for fields that live on structured
  grids. When its writeToFile() method is called it writes both the
  field data and the grid.

  Created a dummy method set() that will (when completed) initialize
  the field using a Lua function. [Later] DONE!!

  A problem: what happens when a Lucee object goes out of scope in Lua
  and gets garbage collected, while another Lucee object still has a
  reference to it? Potential solution: reference count each object?
  Can this be done transparently without changing any Lucee classes?

  Another problem: should time be a global in a Lucee simulation? Most
  likely not.

* October 2nd

  Now completed the creation of FieldPtr and ConstFieldPtr from
  std::vector.

  Need to now allow direct creation of DataStruct without the
  intervention of factories. DONE!

  There is a significant problem with type-saftey for objects created
  in Lua and accessed in Lucee. The issue is that Lua stores the
  object as a void* which means that all type information is lost!
  Although Lua suggests to use the luaL_checkudata method, the problem
  with this in Lucee is a confusion between base class and derived
  class names. I.e. we wish to access base class pointers even when
  the Lua object is a derived object.
  
  One solution is to add *two* metatables: one named after the base
  class and the other named after the derived class. Then, the access
  method should first check for the derived class metatable and then
  the base class metatable. If neither are found it should throw an
  error. [Does this not mean there should only be a derived class
  metatable? Perhaps something better is needed.]

  Added a method to write Field. Need to improve this by putting this
  in Field class and (a) writing the grid in the same h5 file and (b)
  not writing the ghost cells.

* October 1st

  I have written code to convert FieldPtr and ConstFieldPtr to T* and
  const T* respectively. This has two issues: loss of information
  (length is lost) and access to the raw data pointer.

  Perhaps one idea would be to introduce new classes (ConstVecWrap,
  VecWrap) that stores the pointer and the length and that can be
  constructed from FieldPtr and ConstFieldPtr, in addition to a
  std::vector<>. Then, basic functions like flux calculators can have
  signature

#+BEGIN_EXAMPLE
  void flux(ConstVecWrap q, VecWrap flx);
#+END_EXAMPLE 

  Which can be used as
#+BEGIN_EXAMPLE
  std::vector<double> q, flx;
  // set q
  q[0] = 0.0; q[1] = 1.0;
  flux(q, flx);
#+END_EXAMPLE

  This would mean that the Wrap objects must be passed as values as
  references can not be created to temporary.

  WAIT: This is exactly what a FieldPtr is!! So just extend it to
  initialize in addition from std::vector<>. DONE!

* September 30th

  Added more methods to StructuredGridBase class for access from
  Lua. This is an easy but tedious job. However, the basic code is now
  in place. Some objects like Region etc will need to be put into a
  global module (like Lucee.Region {}) so they become available from
  Lua. This can be done later.

  Added getObject() method to LuaTable class. This allows fetching
  reference to Lucee objects stored in Lua tables.

  Made SolverIfc class available from Lua scripts. Now RTE solver
  works from the script. The advance() method needs to be called
  explicitly.

  Removed builData() and buildAlgorithms() methods from SolverIfc.

* September 29th

  The factory methods need to be removed. This will eliminate the
  confusion of registering a factory instead of the actual object
  itself.

  [Later] Removed registration of factory for Grid. To do this I
  simply call the grid factory from the grid class and use the
  assignment operator to construct the object.

  Added a write method to GridIfc class to write grid to hdf5
  file. Seems to work just fine. At this point it seems all basic code
  for making Lucee objects callable from Lua is in place. Next to add
  methods to the LuaTable class to get userdata from the readInput()
  method.

* September 25th

  Most code to make Lucee objects usable from Lua scripts is now
  complete. Testing is needed. Also, need to figure out how to fetch a
  user-data object from a table (i.e. LuaTable object). All need for
  getNew() should now be over. Then, I can remove the ObjCreator class
  from the system and cleanup.

  [Later] There is a problem with the meta-table name embedded in each
  object: i.e. the meta-table name is constructured using the typid of
  the derived class but often the PointerHolder::checkUserType()
  method is called with the base class type. Hence, there is a
  mis-match of typeid() and Lua refuses to run the code. For now, I
  have switched out the luaL_checkudata() method for the
  lua_touserdata() method. Perhaps dynamic casting is needed? [Oct 2:
  Dynamic casts will not work as the basic object is a void* and hence
  C++ has no way of determining the object type]

  One other major problem is the existence of the Factories: when a
  Lua object will be created, it will return a pointer to the factory
  and not the actual object itself. This means the calls are made to
  the factory. This needs to be fixed ASAP.

  Also, writing the Lua callable methods will become rather
  tedious. Perhaps I need to add some helper classes to make this
  easier?

  [Later] The solution to the Factory created objects problem is to
  have two different methods that make the Lua object from C++ code:
  the first applies to classes that support readInput() directly. The
  second applies to classes that are created from a Factory. The
  choice between these methods can be made using two classes, one
  speclized to any T and the other to GenericFactory<T>.

  Also, the method appendLuaCallableMethods() from the derived Factory
  class will need to call the constructed object's
  appendLuaCallableMethods().

* September 23rd

  One way to automatically run the top-level simulation (if it exists)
  is to get the simulation object from C++, check if it really is a
  derived class of SolverIfc, check if it has already been run, and if
  not, run it.

* September 21st

  Just some notes to keep track of things. First, documentation needs
  to be started *now* to ensure it does not get too late to
  document. Need to update the doxygen comments to add more details.

* September 13th

  The LuaModule class needs to be modified to have a map:

#+BEGIN_EXAMPLE
  std::map<std::string, std::vector<luaL_Reg> > refFuncs;
#+END_EXAMPLE 

  or a more complex data-structure. The key could be the derived class
  Id and the vector could be the list of functions to register. The
  derived class should add all the methods it needs to this list.

  When the ObjCreator class moduleRegister() method is called it
  should add, in addition to the methods already added, the base class
  exposed methods and register all these methods. It should create a
  unique meta-table per derived class in so these methods become
  available in a object oriented manner.

  The main method to create the derived class itself should be as it
  is now: i.e. the module name should be the base class ID while the
  creation method name should be derived class ID.

  This will impose a requirement on all Lua callable class to provide
  a static method names appendLuaCallableMethods() to the supplied
  list.

* September 12th

  Figured out how to wrap C++ objects using the current Lucee
  system. Essentially just small modifications to the ObjCreator and
  ObjRegistry classes was needed. This work is in a branch

  https://lucee.googlecode.com/svn/branches/lua-obj

  At this point I have two tasks (a) create two new classes
  corresponding to ObjCreator and ObjRegistry to make Lua objects from
  Lucee objects (I could also simply modify the existing two classes)
  (b) create some means of allowing both base classes and derived
  classes to register methods to operate on the Lua objects.

  The latter task seems much harder to handle in a uniform manner. One
  obvious way to do this would be expect static methods in derived and
  base classes that are always called when the registration
  happens. Of course, this means that these methods must always be
  provided for the system to compile. Even after this is resolved, I
  still need to think of how the call will actually occur. The
  simplest, but least elegant way would be for each class to provide a
  static wrapper method that gets called from Lua. Then, the class
  would do a cast and make the call. Perhaps there is no other way to
  do this.

  However, once this is done, Lucee will have a very powerful manner
  of working. Objects could be created, queried for debugging and
  complete simulations written using Lua.

  Some notes on how to get this to work:

  - Need to rename the ObjCreator class to something more
    meaningful. I.e. as this class adds the Lua call-backs and does
    not really "create" anything.

  - The getNew() method from the ObjCreator can go away as it no
    longer will be needed.

  - The name of the metatable must be combination of the base-class ID
    and the derived class ID. How to do this? This can be done by
    extending the LuaModule class. In this, add the derived class ID
    (store in a vector of strings) and a map of derived class ID to
    callable methods. Then, in the ObjCreator's registerModule method
    we can loop over this and register stuff. (Will this really work?)

* September 10th

  Wrapping a C struct in Lua is very easy. There could still be a
  problem with wrapping C++ classes, though. The issue is that at
  first sight it seems impossible to call the default ctor of the
  class while creating it. Need to figure this out.

  However, once done, getting direct access to Lucee object in Lua
  should be relatively easy task. The main thing is to make the object
  contruction a two-step process: in the first, we register the object
  as usual. In the second we add a method to Lua to call the getNew()
  method. This method will get called, the object will be passed the
  table to construct itself and the resulting data returned. Will need
  to be careful with resource handling.

  A global singleton object holding pointers to all DataStructs,
  Updaters, Grids etc will need to be made. This will allow the C++
  code to access these objects so as to use them when needed.

* September 8th

  After a long time I am getting back to Lucee. I wish to complete the
  system at least to a point where I can solve 1D hyperbolic
  equations. This should be in preparation for the PPPL interview at
  which I would like to present results (if possible) only from Lucee.

  A better way needs to be found than the "table-driven" approach. It
  will be a radical departure from both Facets and Warpx. One option
  would be to have a file like
#+BEGIN_EXAMPLE
  grid = Grid.RectCart1D {
    cells = {10},
    lower = {0.0},
    upper = {1.0},
  }

  q1 = DataStruct.Field1D {
    onGrid = grid,
    numComponents = 5,
    ghost = {1, 2},
  }

  initField = Updater.TXYZFieldSetter2D {
    func = Function.LuaTXYZ {
    numOut = 5,
    f = function (t, x, y, z)
    return 1, 2, 3, 4, 5
    end,
  }

  initField.update(0.0, outVars = {q1})
  q1.sync()
  q1.dump("output.h5")
#+END_EXAMPLE

  This may be a radical change in the way Lucee works, but perhaps
  easier than I think.

* July 9th

  Added TXYZFieldSetter updater. Tested from code. This updater sets
  the supplied array using the provided function.

  Also ensured that updaters are now recognized from input files.

* July 8th

  Added LinCombiner updater. Tested from code. From input file this
  should look like, for example
#+BEGIN_EXAMPLE
  grid = Grid.RectCartGrid2D {
    cells = {10, 20},
    lower = {0.0, 0.0},
    upper = {1.0, 1.0},
  },

  combo = Updater.LinCombiner2D {
    onGrid = "grid",
    coeffs = {0.5, 0.5},
  }
#+END_EXAMPLE

* July 3rd
  
  The next step is to add a Stepper base class. This should run
  specified updater using a time-stepping mode. The stepping mode
  should be provided by derived classes. For example: ConstantDt class
  should provide a constant time-stepping mode where the dt is
  specified.

* July 2nd

  (A few days) No work for a while.

  Added UpdaterIfc class to represent updaters in Lucee. Initially
  these were derived from SolverIfc but had to break this up and make
  UpdaterIfc its own base class.

  One key objective was to allow use of updaters directly from code
  rather than just input files. This was achieved by letting users
  create an updater in code, set the inp/out data structures, and call
  the update(t) method.

  Added FunctionIfc class. This allows the creation of function
  objects that provide a eval() method:
#+BEGIN_EXAMPLE
    std::vector<double> eval(const std::vector<double>& inp);
#+END_EXAMPLE
  The size of input and out vectors can be specified as ctor
  parameters. 

  Redid the LuaFunction class: renamed it LuaTXYZFunction and it now
  derives from FunctionIfc. The LuaTable class had to be expanded to
  allow for getting access to references to Lua functions. This allows
  creation of LuaTXYZFunction from input file blocks.

* June 17th

  (A few days). Now have Fields initialized from input files. Also
  added a LuaFunction class that allows wrapping a Lua function in
  C++.

  The LuaTable class had a major bug in which the Lua stack size kept
  growing. This caused a segfault on my new Mac. Wrote a set of macros
  to track stack size. Now the stack is exactly balanced in each call.

  One thing that Lucee needs is a general set of vector operators:
  div, grad and curl. These operators should work on body fitted grids
  and should preserve the discrete vector calculus identities. One way
  to do this is to implement the Support Operator Method (SOM) for the
  discrete vector calculus operators. This would allow a combination
  of these operators to construct, for example, a Navier-Stokes
  solver.

* June 5/6th

  Completed reading of grids from input files and writing them out to
  HDF5.

  Major work to create typeMap in the LuaTable class. This allows the
  implementation of the getNamesOfType() method needed in
  SolverAssembly.
  
* June 4th
  
  Added GridBase class, derived StructuredGridBase from it and created
  a "Grid" module and registered it into Lucee.

* June 1st

  Completed BodyFittedGridBase and RectCartGrid classes. Tested the
  methods. Also added default ctor in Vec3.

  Why not use Vec3 for coordinates and vectors? The answer is that
  fixed sized vectors of size 3 are simpler, and probably much faster.

* May 28th

  - Fixed getSubCompView with ghost indices.
  - Seems like that for getSubCompView() should really have its
    component indices always starting with index 0. (Now fixed)

* May 27th

  Added ghost indices to fields. A lot of work to fix. Still does not
  work with slicing and sub-component views.

* May 26th

  - Created a Vec3 class to store vectors in 3D space. In preparation
    for adding a body-fitted grid class.

  - Started on BodyFittedGrid. The idea is to have a base class called
    BodyFittedGridBase from which BodyFittedGrid and CartGrid will be
    derived.

* May 25th

  Back to working on Lucee after a long while. Added a SolverAssembly
  class that will serve as a general purpose solver to assemble a
  simulation using grids, data and updaters.

  Need to figure out a way to avoid specifying dimensions in the input
  file. Everything can be determined from the dimension of the grid.

  Example::
#+BEGIN_EXAMPLE
    simulation = Solver.Assembly {
      domain = Grid.CartGrid {
        lower = {0.0, 0.0},
	upper = {1.0, 2.0},
	cells = {10, 20},
      },

      q = DataStruct.Field { 
        onGrid = domain,	
	numComponents = 5,
	ghost = {1, 1},
      },

      qOld = DataStruct.Field { 
        onGrid = domain, 
	numComponents = 5
      },

      qMom = DataStructAlias.Field {
        target = q,
	componentRange = {1, 4},
      },

      init = Updater.InitField {
        onGrid = domain,
      },

      stepper = Stepper.ConstantDt {
        dt = 1.5e-3,
	initialize = {initQStep, initiQoldStep},

	initQStep = Step {
	  updater = init,
	  out = {q}
	},
	initQoldStep = Step {
	  updater = init,
	  out = {q}
	},

      },
    }
#+END_EXAMPLE

* April 2nd - 6th

  No work on Lucee. Need to get back on this and bring the RTE solver
  to a completion.

* April 1st

  Trying to figure out particular solutions at dummy nodes. Seems like
  a real mess.

* March 31th

  Started work on dummy-node inclusion. Not working or complete
  yet. However basic ideas are clear.

* March 26th, 27th, 28th, 29th, 30th

  No work on Lucee.

* March 25th

  - Added cases 4 and 5 to verification studies. Setting
    varpi=1.0-1e-8 works well for cases when varpi=1.0. All decimal
    places for irradiances are computed correctly for irradiances.

* March 24th.

  No work.

* March 23rd

  - Now writing out irradiances. Tested irradiance E_0 with Siewert
    benchmark paper. Are exactly correct to all significant digits.
  - Next need to impliment dummy-node-inclusion method to get
    radiances at ordinates with zero weight.

* March 22nd

  - Added code to compute irradiances. Not tested and irradiances not
    yet written to file.
  - Added innerProduct() method to Vector class. NOT TESTED. Too tired
    to do this tonight but must do this.

* March 21st

  - Fixed a bug in hasStrVec() and hasNumVec() methods of LuaTable
    class. Not enough tests or else this would be caught earlier.
  - Added basic code to compute irradiances. Not complete yet.

* March 20th

  - Added duplicate() method to Array class.
  - Added method to write an array to HDF5 file. One needs to be a bit
    careful here as HDF5 expects data in row-major order while the
    default array layout is column major order.
  - Now writing out the radiance data as a numMode x N array rather
    than a separate array per mode.

* March 19th

  - Added code to compute half-space solution. Not tested.
  - Thought of using dummy node inclusion method as an interpolation
    technique for the RTE. Seems a better technique than the
    source-function integration method of Siwert.

* March 18

  - Now writing out RteHomogeneousSlab data as HDF5 files.
  - Started on benchmarking exercise with Garcia and Siewert paper.

* March 17

  - Debugged RteHomogeneousSlab. It now works.
  - Added HDF5 I/O classes to Lucee. Do not work for reading Vec
    attributes.

* March 15, 16

  - Now RteHomogeneousSlab solver basic algorithm is complete. Data
    yet to be written out. Now sure if to just do it in HDF5 or do
    some intermediate step before that.
  - Still need to figure out how to compute the irradiances.

* March 14
  
  - Added getView() method to matrix class.
  - Lot more work on RTE slab solver. Now close to being done.

* March 12, 13th

  - Added a document RteHomogeneousSlab.tex that describes the
    algorithm step by step.
  - Added scaleRows() and scaleCols() methods to the Matrix class.
  - More work on RTE solver.

* March 11th

  - Added phase function classes: HG phase function and phase function
    based on expansion coefficients.

* March 10th

  - Added LcMathLib file with math functions. Added gauleg() method.
  - Removed FcSimulation files. Now main() directly creates the
    SolverIfc class and drives.
  - Now have GSL properly linked. Some more familiarity with cmake is
    needed to get this figured out properly.

* March 9th

  - Added basic methods in LuaTable. Tested these. Next to implement
    the vector forms of these methods. Also, need to be careful about
    not polluting the stack.
  - All methos in LuaTable now implemented. Need to think about how to
    get and evaluate functions in Lua.
  - Module registration system needed re-work. Now seems to work.

* March 8th

  - Figured out way to use Lua tables. The basic idea it to use the
    luaL_ref() method to get a reference to the internal Lua table
    object. This can then be used to implement a persistent table
    access class.
  - Added a class LcLuaTable to represent tables. Not completed.

* March 5th, 6th and 7th

  No work on Lucee

* March 4th

  - Added ObjRegistry and ObjCreator classes. These were simply copied
    over from a old Lucee tag.

* March 3rd 2010

  - More playing around with Lua and object registration/creation
    process. Now figured out how to get global values and from tables,
    add new C call-back methods and register new modules.
  - Added lucee executable and command-line parsing, Simulation class.

* March 2nd 2010

  - Made notes on ideas for solvers Lucee. Added a class SolverIfc
    that defines the basic interface supported by all Lucee
    solvers. This will evolve as features are added, in particular
    when going parallel.
  - Starting to get better hold of reading table data out of LUA. Made
    LUA not use dynamic libraries.

* March 1st 2010

  - Fixed the getSubCompView() method. The solution is to get rid of
    the getLowIndex() method and use getIndex() method with 0 as the
    final index. This now allows selection of a range of components in
    a field to create a new field.
  - Renamed getGenIndex() -> genIndex().
  - Completed the solve() method in LcLinAlgebra. Unlike other
    linear-algebra methods, this one modifies the input matrix and
    also expects the matrices to be contiguous.

* Feb 28th 2010

  - Now getView() method works in LcField. The selection of
    sub-components of the field object seems rather tricky.
  - Discovered problem: when chaging start index both ai[0] and
    start[] are modified such that the modfied and new indexer return
    the same linear index. That is not what we want in selecting the
    sub-components. Instead, we want to just change ai[0] by sc so
    that the correct reference to the sc component is returned on
    passing 0 in the sub-comp-view field. Not yet fixed.

* Feb 27th 2010

  - Starting to add ability to find external libraries. First one: GSL
    for RTE work.

* Feb 26th 2010

  - Added getRow() and getCol() methods to Matrix class. Also added
    the ability to create Vector object from a Array<1, T>
    object. This allows the getRow() and getCol() methods to return
    Vector objects.

* Feb 25th 2010

  - To support deflating of Array the INDEXER template parameter had
    to be made a class template. Now, the Array declaration looks
    mighty ugly:
#+BEGIN_EXAMPLE
    template <unsigned NDIM, typename T, template <unsigned> class INDEXER  = Lucee::RowMajorIndexer>
    class Array;
#+END_EXAMPLE
    Further, Array<NDIM> class needs to friend itself to access private
    stuff from Array<RDIM>, where NDIM != RDIM. This horror looks
    like:
#+BEGIN_EXAMPLE
    template <unsigned RDIM, typename TT, template <unsigned> class IINDEXER> friend class Array;
#+END_EXAMPLE
  - Added deflate() methods to both indexer classes and to the array
    class. Seems to work just fine.
  - Derived classes of Array will need to provide their own deflate
    methods. In particular, Matrix class should support getting a row
    or a column. What should Field do?

* Feb 24th 2010

  - Completed Row and Col major sequencers.
  - Added a typedef to Row and Col indexers to allow creation of
    proper sequencers. This allows arrays and derived classes to use
    the correct indexer/sequencer pair.

* Feb 23rd 2010

  - Started work on row-major sequencers. Not complete yet.
  - Indexers may need to return associated sequencers.

* Feb 22nd 2010

  - Discovered a bug in indexers. It seems indexer hierachy needs to
    be rethought. The basic indexer class (common to linear indexing
    mechanisms) needs to be abstracted out into a base class. Then,
    the row and column major indexers will inhert from this base class
    and provide the coefficients in the linear mapping. It is not so
    clear what the system should be for non-linear mapping.
  - Completely redid the indexing system. Introduced a LinIndexer
    class from which the RowMajor and ColMajor indexer classes
    derive. Now should allow for slicing and deflating of arrays.

* Feb 21st 2010

  - Hooked in ctests into Lucee. Now one can run all the tests with
    one commmand in the top-level build directory, either 'ctest' or
    'make tests'.
  - Finished FieldItr class. This allows the following:
#+BEGIN_EXAMPLE
    int lo[2], up[2];
    Lucee::Box<2, int> rgn(lo, up);
    Lucee::Field<2, double> elcFld(rgn, 3);

    Lucee::FieldPtr<2> ptr = eclFld.createPtr();
    elcFld.setPtr(ptr, 5, 5);
    
    ptr[0] = 1.0;
    ptr[1] = 2.0;
    ptr[2] = 3.0;
#+END_EXAMPLE
    I.e, using FieldPtr one can access/modify the elements at a
    location in the field.
  - Finished ConstFieldPtr class. Same semantics as FieldPtr except
    that is allows pointing to constant Field objects.
  - Finished the getSlice() method in Array object. How do slices of
    derived classes work? Probably need a covariante return
    thunk. Also, this brought up the issue of being able to assign all
    the elements of a sliced-array.
