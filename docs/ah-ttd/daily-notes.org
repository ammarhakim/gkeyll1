# -*- org -*-

* March 14
  
  - Added getView() method to matrix class.
  - Lot more work on RTE slab solver.

* March 12, 13th

  - Added a document RteHomogeneousSlab.tex that describes the
    algorithm step by step.
  - Added scaleRows() and scaleCols() methods to the Matrix class.
  - More work on RTE solver.

* March 11th

  - Added phase function classes: HG phase function and phase function
    based on expansion coefficients.

* March 10th

  - Added LcMathLib file with math functions. Added gauleg() method.
  - Removed FcSimulation files. Now main() directly creates the
    SolverIfc class and drives.
  - Now have GSL properly linked. Some more familiarity with cmake is
    needed to get this figured out properly.

* March 9th

  - Added basic methods in LuaTable. Tested these. Next to implement
    the vector forms of these methods. Also, need to be careful about
    not polluting the stack.
  - All methos in LuaTable now implemented. Need to think about how to
    get and evaluate functions in Lua.
  - Module registration system needed re-work. Now seems to work.

* March 8th

  - Figured out way to use Lua tables. The basic idea it to use the
    luaL_ref() method to get a reference to the internal Lua table
    object. This can then be used to implement a persistent table
    access class.
  - Added a class LcLuaTable to represent tables. Not completed.

* March 5th, 6th and 7th

  No work on Lucee

* March 4th

  - Added ObjRegistry and ObjCreator classes. These were simply copied
    over from a old Lucee tag.

* March 3rd 2010

  - More playing around with Lua and object registration/creation
    process. Now figured out how to get global values and from tables,
    add new C call-back methods and register new modules.
  - Added lucee executable and command-line parsing, Simulation class.

* March 2nd 2010

  - Made notes on ideas for solvers Lucee. Added a class SolverIfc
    that defines the basic interface supported by all Lucee
    solvers. This will evolve as features are added, in particular
    when going parallel.
  - Starting to get better hold of reading table data out of LUA. Made
    LUA not use dynamic libraries.

* March 1st 2010

  - Fixed the getSubCompView() method. The solution is to get rid of
    the getLowIndex() method and use getIndex() method with 0 as the
    final index. This now allows selection of a range of components in
    a field to create a new field.
  - Renamed getGenIndex() -> genIndex().
  - Completed the solve() method in LcLinAlgebra. Unlike other
    linear-algebra methods, this one modifies the input matrix and
    also expects the matrices to be contiguous.

* Feb 28th 2010

  - Now getView() method works in LcField. The selection of
    sub-components of the field object seems rather tricky.
  - Discovered problem: when chaging start index both ai[0] and
    start[] are modified such that the modfied and new indexer return
    the same linear index. That is not what we want in selecting the
    sub-components. Instead, we want to just change ai[0] by sc so
    that the correct reference to the sc component is returned on
    passing 0 in the sub-comp-view field. Not yet fixed.

* Feb 27th 2010

  - Starting to add ability to find external libraries. First one: GSL
    for RTE work.

* Feb 26th 2010

  - Added getRow() and getCol() methods to Matrix class. Also added
    the ability to create Vector object from a Array<1, T>
    object. This allows the getRow() and getCol() methods to return
    Vector objects.

* Feb 25th 2010

  - To support deflating of Array the INDEXER template parameter had
    to be made a class template. Now, the Array declaration looks
    mighty ugly:
#+BEGIN_EXAMPLE
    template <unsigned NDIM, typename T, template <unsigned> class INDEXER  = Lucee::RowMajorIndexer>
    class Array;
#+END_EXAMPLE
    Further, Array<NDIM> class needs to friend itself to access private
    stuff from Array<RDIM>, where NDIM != RDIM. This horror looks
    like:
#+BEGIN_EXAMPLE
    template <unsigned RDIM, typename TT, template <unsigned> class IINDEXER> friend class Array;
#+END_EXAMPLE
  - Added deflate() methods to both indexer classes and to the array
    class. Seems to work just fine.
  - Derived classes of Array will need to provide their own deflate
    methods. In particular, Matrix class should support getting a row
    or a column. What should Field do?

* Feb 24th 2010

  - Completed Row and Col major sequencers.
  - Added a typedef to Row and Col indexers to allow creation of
    proper sequencers. This allows arrays and derived classes to use
    the correct indexer/sequencer pair.

* Feb 23rd 2010

  - Started work on row-major sequencers. Not complete yet.
  - Indexers may need to return associated sequencers.

* Feb 22nd 2010

  - Discovered a bug in indexers. It seems indexer hierachy needs to
    be rethought. The basic indexer class (common to linear indexing
    mechanisms) needs to be abstracted out into a base class. Then,
    the row and column major indexers will inhert from this base class
    and provide the coefficients in the linear mapping. It is not so
    clear what the system should be for non-linear mapping.
  - Completely redid the indexing system. Introduced a LinIndexer
    class from which the RowMajor and ColMajor indexer classes
    derive. Now should allow for slicing and deflating of arrays.

* Feb 21st 2010

  - Hooked in ctests into Lucee. Now one can run all the tests with
    one commmand in the top-level build directory, either 'ctest' or
    'make tests'.
  - Finished FieldItr class. This allows the following:
#+BEGIN_EXAMPLE
    int lo[2], up[2];
    Lucee::Box<2, int> rgn(lo, up);
    Lucee::Field<2, double> elcFld(rgn, 3);

    Lucee::FieldPtr<2> ptr = eclFld.createPtr();
    elcFld.setPtr(ptr, 5, 5);
    
    ptr[0] = 1.0;
    ptr[1] = 2.0;
    ptr[2] = 3.0;
#+END_EXAMPLE
    I.e, using FieldPtr one can access/modify the elements at a
    location in the field.
  - Finished ConstFieldPtr class. Same semantics as FieldPtr except
    that is allows pointing to constant Field objects.
  - Finished the getSlice() method in Array object. How do slices of
    derived classes work? Probably need a covariante return
    thunk. Also, this brought up the issue of being able to assign all
    the elements of a sliced-array.
