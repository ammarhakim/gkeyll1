# -*- org -*-

* May 26th

  Created a Vec3 class to store vectors in 3D space. In preparation
  for adding a body-fitted grid class.

* May 25th

  Back to working on Lucee after a long while. Added a SolverAssembly
  class that will serve as a general purpose solver to assemble a
  simulation using grids, data and updaters.

  Need to figure out a way to avoid specifying dimensions in the input
  file. Everything can be determined from the dimension of the grid.

  Example::

    simulation = Solver.Assembly {
      domain = Grid.CartGrid {
        lower = {0.0, 0.0},
	upper = {1.0, 2.0},
	cells = {10, 20},
      },

      q = Data.Field { 
        onGrid = domain,	
	numComponents = 5
      },

      qOld = Data.Field { 
        onGrid = domain, numComponents = 5 
      },

      qMom = DataAlias.Field {
        target = q,
	componentRange = {1, 4},
      },

      init = Updater.InitField {
        onGrid = domain,
      },

      stepper = Stepper.ConstantDt {
        dt = 1.5e-3,
	initialize = {initQStep, initiQoldStep},

	initQStep = Step {
	  updater = init,
	  out = {q}
	},
	initQoldStep = Step {
	  updater = init,
	  out = {q}
	},

      },
    }

* April 2nd - 6th

  No work on Lucee. Need to get back on this and bring the RTE solver
  to a completion.

* April 1st

  Trying to figure out particular solutions at dummy nodes. Seems like
  a real mess.

* March 31th

  Started work on dummy-node inclusion. Not working or complete
  yet. However basic ideas are clear.

* March 26th, 27th, 28th, 29th, 30th

  No work on Lucee.

* March 25th

  - Added cases 4 and 5 to verification studies. Setting
    varpi=1.0-1e-8 works well for cases when varpi=1.0. All decimal
    places for irradiances are computed correctly for irradiances.

* March 24th.

  No work.

* March 23rd

  - Now writing out irradiances. Tested irradiance E_0 with Siewert
    benchmark paper. Are exactly correct to all significant digits.
  - Next need to impliment dummy-node-inclusion method to get
    radiances at ordinates with zero weight.

* March 22nd

  - Added code to compute irradiances. Not tested and irradiances not
    yet written to file.
  - Added innerProduct() method to Vector class. NOT TESTED. Too tired
    to do this tonight but must do this.

* March 21st

  - Fixed a bug in hasStrVec() and hasNumVec() methods of LuaTable
    class. Not enough tests or else this would be caught earlier.
  - Added basic code to compute irradiances. Not complete yet.

* March 20th

  - Added duplicate() method to Array class.
  - Added method to write an array to HDF5 file. One needs to be a bit
    careful here as HDF5 expects data in row-major order while the
    default array layout is column major order.
  - Now writing out the radiance data as a numMode x N array rather
    than a separate array per mode.

* March 19th

  - Added code to compute half-space solution. Not tested.
  - Thought of using dummy node inclusion method as an interpolation
    technique for the RTE. Seems a better technique than the
    source-function integration method of Siwert.

* March 18

  - Now writing out RteHomogeneousSlab data as HDF5 files.
  - Started on benchmarking exercise with Garcia and Siewert paper.

* March 17

  - Debugged RteHomogeneousSlab. It now works.
  - Added HDF5 I/O classes to Lucee. Do not work for reading Vec
    attributes.

* March 15, 16

  - Now RteHomogeneousSlab solver basic algorithm is complete. Data
    yet to be written out. Now sure if to just do it in HDF5 or do
    some intermediate step before that.
  - Still need to figure out how to compute the irradiances.

* March 14
  
  - Added getView() method to matrix class.
  - Lot more work on RTE slab solver. Now close to being done.

* March 12, 13th

  - Added a document RteHomogeneousSlab.tex that describes the
    algorithm step by step.
  - Added scaleRows() and scaleCols() methods to the Matrix class.
  - More work on RTE solver.

* March 11th

  - Added phase function classes: HG phase function and phase function
    based on expansion coefficients.

* March 10th

  - Added LcMathLib file with math functions. Added gauleg() method.
  - Removed FcSimulation files. Now main() directly creates the
    SolverIfc class and drives.
  - Now have GSL properly linked. Some more familiarity with cmake is
    needed to get this figured out properly.

* March 9th

  - Added basic methods in LuaTable. Tested these. Next to implement
    the vector forms of these methods. Also, need to be careful about
    not polluting the stack.
  - All methos in LuaTable now implemented. Need to think about how to
    get and evaluate functions in Lua.
  - Module registration system needed re-work. Now seems to work.

* March 8th

  - Figured out way to use Lua tables. The basic idea it to use the
    luaL_ref() method to get a reference to the internal Lua table
    object. This can then be used to implement a persistent table
    access class.
  - Added a class LcLuaTable to represent tables. Not completed.

* March 5th, 6th and 7th

  No work on Lucee

* March 4th

  - Added ObjRegistry and ObjCreator classes. These were simply copied
    over from a old Lucee tag.

* March 3rd 2010

  - More playing around with Lua and object registration/creation
    process. Now figured out how to get global values and from tables,
    add new C call-back methods and register new modules.
  - Added lucee executable and command-line parsing, Simulation class.

* March 2nd 2010

  - Made notes on ideas for solvers Lucee. Added a class SolverIfc
    that defines the basic interface supported by all Lucee
    solvers. This will evolve as features are added, in particular
    when going parallel.
  - Starting to get better hold of reading table data out of LUA. Made
    LUA not use dynamic libraries.

* March 1st 2010

  - Fixed the getSubCompView() method. The solution is to get rid of
    the getLowIndex() method and use getIndex() method with 0 as the
    final index. This now allows selection of a range of components in
    a field to create a new field.
  - Renamed getGenIndex() -> genIndex().
  - Completed the solve() method in LcLinAlgebra. Unlike other
    linear-algebra methods, this one modifies the input matrix and
    also expects the matrices to be contiguous.

* Feb 28th 2010

  - Now getView() method works in LcField. The selection of
    sub-components of the field object seems rather tricky.
  - Discovered problem: when chaging start index both ai[0] and
    start[] are modified such that the modfied and new indexer return
    the same linear index. That is not what we want in selecting the
    sub-components. Instead, we want to just change ai[0] by sc so
    that the correct reference to the sc component is returned on
    passing 0 in the sub-comp-view field. Not yet fixed.

* Feb 27th 2010

  - Starting to add ability to find external libraries. First one: GSL
    for RTE work.

* Feb 26th 2010

  - Added getRow() and getCol() methods to Matrix class. Also added
    the ability to create Vector object from a Array<1, T>
    object. This allows the getRow() and getCol() methods to return
    Vector objects.

* Feb 25th 2010

  - To support deflating of Array the INDEXER template parameter had
    to be made a class template. Now, the Array declaration looks
    mighty ugly:
#+BEGIN_EXAMPLE
    template <unsigned NDIM, typename T, template <unsigned> class INDEXER  = Lucee::RowMajorIndexer>
    class Array;
#+END_EXAMPLE
    Further, Array<NDIM> class needs to friend itself to access private
    stuff from Array<RDIM>, where NDIM != RDIM. This horror looks
    like:
#+BEGIN_EXAMPLE
    template <unsigned RDIM, typename TT, template <unsigned> class IINDEXER> friend class Array;
#+END_EXAMPLE
  - Added deflate() methods to both indexer classes and to the array
    class. Seems to work just fine.
  - Derived classes of Array will need to provide their own deflate
    methods. In particular, Matrix class should support getting a row
    or a column. What should Field do?

* Feb 24th 2010

  - Completed Row and Col major sequencers.
  - Added a typedef to Row and Col indexers to allow creation of
    proper sequencers. This allows arrays and derived classes to use
    the correct indexer/sequencer pair.

* Feb 23rd 2010

  - Started work on row-major sequencers. Not complete yet.
  - Indexers may need to return associated sequencers.

* Feb 22nd 2010

  - Discovered a bug in indexers. It seems indexer hierachy needs to
    be rethought. The basic indexer class (common to linear indexing
    mechanisms) needs to be abstracted out into a base class. Then,
    the row and column major indexers will inhert from this base class
    and provide the coefficients in the linear mapping. It is not so
    clear what the system should be for non-linear mapping.
  - Completely redid the indexing system. Introduced a LinIndexer
    class from which the RowMajor and ColMajor indexer classes
    derive. Now should allow for slicing and deflating of arrays.

* Feb 21st 2010

  - Hooked in ctests into Lucee. Now one can run all the tests with
    one commmand in the top-level build directory, either 'ctest' or
    'make tests'.
  - Finished FieldItr class. This allows the following:
#+BEGIN_EXAMPLE
    int lo[2], up[2];
    Lucee::Box<2, int> rgn(lo, up);
    Lucee::Field<2, double> elcFld(rgn, 3);

    Lucee::FieldPtr<2> ptr = eclFld.createPtr();
    elcFld.setPtr(ptr, 5, 5);
    
    ptr[0] = 1.0;
    ptr[1] = 2.0;
    ptr[2] = 3.0;
#+END_EXAMPLE
    I.e, using FieldPtr one can access/modify the elements at a
    location in the field.
  - Finished ConstFieldPtr class. Same semantics as FieldPtr except
    that is allows pointing to constant Field objects.
  - Finished the getSlice() method in Array object. How do slices of
    derived classes work? Probably need a covariante return
    thunk. Also, this brought up the issue of being able to assign all
    the elements of a sliced-array.
