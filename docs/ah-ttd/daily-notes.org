# -*- org -*-

* December 25th

  Added RectCoordSys class. Derived classes will provide rotation for
  vectors, tensors, etc.

* December 24th

  More work on WavePropagationUpdater. Nearly completed. Once
  transverse terms are added the localRgn box may need to be extended
  to give effects of corner cells on the first row of cells.

  Should add a numerical flux function to each equation system. Then,
  let the equation system decide which flux to use.

  Perhaps it is important to introduce direction in the HyperEquation
  class. Otherwise non-isotropic systems can not be simulated. One
  option would be to introduce a RectCoordSys class that represents a
  coordinate system as three ortogonal unit vectors. This could be
  then passed to HyperEquation class to represent direction.

* December 19th

  Add a rotation class to Lucee. This will allow doing 2D and 3D
  problems. Also, add a vector to WavePropagationUpdater to indicate
  which directions to update. This will allow doing time-split
  algorithms from the input file by carefully combining them in the
  Lua script.

  How to do transverse terms in the correct way?

  Move the test updaters to new 'proto' directory.

* December 18th

  Added and tested duplicate() method to Field class. Now duplicates
  can be created from Lua script. Should open up the way to adpative
  time-stepping.

* December 16th

  Now can create a matrix from a raw pointer.

  PPPL may actually happen! In this case I need to start sprucing up
  lucee by documenting it in detail, specially its input file
  scripting format.

  There is no need for the modifications to the directional
  sequencer. Added a new function deflate() to the Region class to
  allow creation of a box with shape 1 in a specified direction.

   The class Updater should be renamed to something else. Perhaps
   Algorithm?

* December 12th

  - Need to modify the directional sequencer. This should work something
    like the following.
#+BEGIN_EXAMPLE
      DirSequencer<2> seq(rgn, dir);
      while (seq.step())
      {
        while (seq.sweep())
	{
          seq.fillWithIndex(idx);
	  // do something at idx
	}
      }
#+END_EXAMPLE

  - Added WavePropagationUpdater. This is templated over
    dimension. Still not complete, but should be easy. DirSequencer
    needs to be modified as described above.

  - How to create a field of matrices? Perhaps create a matrix by
    reusing the memory in a FieldPtr? Once this is done, then Fields
    can be created in the WavePropagationUpdater to store the various
    needed quantities.

  - For allowing for adaptive time-stepping, duplicate() method needs
    to be added to the derived classed of Array.

* December 11th

  - Added directional sequencer. This does two things: first, it
    allows sweeping a region in a specified direction. Second, it
    allows getting indices from a stencil. For example, consider a 2D
    region. We can perform X-sweeps or Y-sweeps. DirSequencer allows
    this.

  - Now error messages from tests are being put into a different
    file. This means only PASSED/FAILED message is printed from a unit
    test and it there are FAILED tests they go into a different file.

   Do I need to add directions back to flux/waves etc methods in
   hyperbolic equations? For example: in wave3D how to do transvere
   corrections? One needs to split X direction fluctuations into Y and
   Z direction fluctuations.

   What to do about rotations?

   A note on FieldPtrs: FieldPtrs can be sent to const
   ConstFieldPtr. Std::vector can be converted to FieldPtr or
   ConstFieldPtr. FieldPtr of given size can be created.

* December 2nd

  Black box testing can only uncover bugs but never prove that there
  are none. To ensure that bugs do not exist one needs to examine the
  structure of the algorithm and prove, mathematically, that it is
  correct, i.e. does what it promises.

  How do we create computational physics algorithms that can be
  trusted by construction?

  In brief the essential idea is: if you select the correct
  mathematical model and create a provably correct algorithm, then the
  steps of verification and validation are not needed, or just a
  pleasant conformation of what you already built into the system. Or,
  even more briefly, lets get it right in the first place.

  How can such a proof-based method be applied to computational
  physics? There are several challenges. First, we need to ensure that
  the chosen mathematical equations describe the physical system to be
  modelled with sufficient detail. This is impossible in general and
  approximations always need to be made. The degree to which these
  approximations affect the physical realism of the model is hard to
  determine and, ultimately, direct comparisons with experimental
  observations must be made. [Scientific Conception of the World]
  Second, once the mathematical equations are selected, a method to
  solve them needs to be developed.

  To select an accurate mathematical model an a priori approach is
  needed. The tradition "validation" step of comparing computational
  results afterwards to experiments, no matter how many, is not
  sufficient to prove that the mathematical model chosen is
  correct. What is needed is a clear understanding of the
  approximations made and if those are appropriate for representing
  the physical system being modeled. For example, often, if a system
  of equations is complex, simplifying assumptions of length and
  time-scales are made. However, although these approximations may be
  valid on a global scale, they are not valid locally, specially in
  regions where spatial and/or temporal gradients of solutions can be
  of the same order as the ignored scales.

  As a first step we can ignore the complexities of selecting an
  accurate mathematical model and focus on developing a provably
  correct algorithm.

  Remark 1: Is this not just the standard "verification" analysis? At
  first sight it seems like it, however, the distinction made in the
  first paragraph holds between verification and what is being
  proposed here. I.e. verification, as it is a post-algorithm and
  implementation step, can only uncover bugs but not prove they do not
  exist. Here, an analysis is being made on what it takes to construct
  a provably correct algorithm. It need not even be implemented [End
  remark]

  Remark 2: Is this not what all numerical scheme developers do?
  I.e. do they not show that their scheme converges, has so-and-so
  order? I submit that this process is only the first step. Even if
  the scheme converges with some order, it is not clear if it actually
  preserves the mathematical properties of the equation system. [End
  remark]

  What is being proposed here is the following. A scheme must solve
  the mathematical equations accurately, i.e. the scheme must provably
  converge to the correct solution in the appropriate limit. However,
  this is not enough. If the mathematical equations have certain
  properties, it must be proved that the scheme satisfies those
  properties. The larger the set of properties the scheme can be
  proved to satisfy, the greater the confidence in having developed a
  correct scheme. Note that this step does not actually require the
  implementation of the scheme in executable code, but only a
  sufficient knowledge of the mathematical properties of the system
  being solved and certain dexterity in manipulating the formulas
  involved in the scheme.

  What about actual implementation? For the scheme to be useful an
  implementation must be constructed. This step is fraught with
  difficulties. First, although our scheme may satisfy a broad variety
  of properties, its implementation is not guaranteed to automatically
  inherit this. This is due to the gap between a programming language
  and the language in which mathematical manipulations are done. A
  reason for the gap is the lack of formalization of the manipulations
  needed in the proofs. [Descartes calculating machine]. This gap will
  not close anytime soon. What is required is a new approach in which
  the scheme can be expressed directly, proofs performed (manually
  would be good enough) and transformed into executable code.

  Remark: The construction of a scheme is not unique: i.e. several
  schemes can be constructed for the same mathematical model. If each
  of these schemes is proved to be correct, then the one with the most
  efficient implementation can be selected. [End remark]

  So the question comes up: given the state of art, what programming
  techniques to adopt to ensure, as far as possible that the
  implementation is faithful to the scheme?

* November 8th

  Field and array classes need to be tested with the alias-ed
  fields. Aliases don't always seem to work, for some reason.

  Turns out that the Field::getSubCompView() method is not returning
  the correct sub-array. The base class methods in Array do not work
  correctly with sliced fields. This is a very important bug to fix
  ASAP. A clue: when using a sliced subComView field one does, for
  example, ez(i,j,0). However, the base class code actually uses the
  index ez(i,j,-2), in case ez points to the 3rd component of a
  3-component field.

  Big fixed! The solution is to reset the indexer and array start
  indices separately. This makes the getSubCompView a very tricky
  method to implement, but it looks likes the only way it can be done.

* November 7th

  Completed alias method for fields. This was relatively simple. Also
  added divergence operator to the structured grid field. Presently
  only works on rectangular grids.

  In the 2D TM Maxwell solver, the boundary conditions need to be
  figured out for the psi (correction) potential.

  Need to add BC updaters.

  Lucee is turning into a mixed OO and procedural system. Which is
  good as not everything needs to be an updater and this simplifies
  the input file code enormously. No endless writing of updater
  anymore.

* November 6th

  Completed TM Maxwell solver in 2D. This is to test ideas on how to
  conserve divergence errors in Maxwell equations.

  Need to write an alias function.

* October 31st

  Numerical flux class needs to be defined. The interface method
  should have the following interface.
#+BEGIN_EXAMPLE
    flux(ql, qr, fl, fr, sl, sr)
#+END_EXAMPLE
  where ql, qr are left/right conserved variables, fl, fr are
  left/right fluxes and sl, sr and left/right speeds.

* October 13th

  Probably should switch to Tech-X CMake system. Need to design the
  basic hyperbolic equation class. The solver should be numerical flux
  based and not wave based. This allows flexibility as the wave
  numerical fluxe can then be used in other schemes like MUSCL, DG
  etc. Somehow, when using wave propagation scheme the system should
  use the wave/fluctuation form of the update formula. The schemes
  should be dimensionally independent, i.e. work in 1D, 2D and 3D and
  on body fitted grids. Hence, one set of updaters should be enough
  for all structured grids.

  In the future I may wish to use unstructured grids.
  
  For documentation I should start using Spinx more extensively than
  now. Each piece needs to be documented carefully. The RTE solver
  needs to be documented and can perhaps serve as a template for other
  documents. GUI/Mouse driven systems like LyX or TeXMac do not work
  documentsfor me.

* October 10th

  Why is a PointerHolder class needed. One can simply store the object
  pointer itself and register the deletion class. ANS: It is needed
  because the new() method can be called after the pointer holder is
  allocated.

  Added a class LuaObjTypeId. This checks type of the object by
  casting to PointerHolder<BasicObj> and getting the stored ID
  strings.

* October 8th

  Working on wrapping Updater in Lua. Completed this. Now updaters can
  be called from Lua. The setIn() and setOut() methods must be called
  before the advance() method is called. Advance() returns a status
  and a suggested time-step. One issue is that the input and output
  types are not type-checked. This may be impossible in the present
  system as the type information is lost in putting stuff into Lua and
  getting it back (Lua stores void* to an object). One option would be
  store the typeid of each created object in the ObjRegistry
  class. Then, this could be queried when needed to ensure type
  saftey.

  Need to start documenting the Lua API.

* October 4th

  Added methods copy() and clear() to Field class. This allows copying
  from a field and setting all field values to given number.

  Also found a nasty bug in the RectCartGrid which was returning the
  incorrect centriod coordinates. Shows need to for more careful
  testing: essentially the getCentriod() method was assuming lower
  bounds of 0.0 for all grids irrespective of actual lower bounds.

  Added accumulate() method to Field and Array classes. This now
  completes basic operations of fields and makes them available from
  Lua, allowing for writing more complex algorithms.

  Should I rename Updater -> Algorithm? Seems like a more natural name
  than updater. One issue is what to do with time? Perhaps the
  simulation time needs to become a global? Not sure what to do yet.
#+BEGIN_EXAMPLE
  grid = Grid.RectCart1D { 
    lower = {0.0}, upper = {1.0}, cells = {100}
  }

  q = DataStruct.Field1D {
    onGrid = grid, numComponents = 5, ghost = {2, 2}
  }

  qOld = DataStruct.Field1D {
    onGrid = grid, numComponents = 5, ghost = {2, 2}
  }

  function initQ(x, y, z)
    local rho, pr=3.0
    if x>0.5 then
      rho, pr = 1.0, 1.0
    end
    Er = pr/(1.4-1)
    return rho, 0, 0, 0, Er
  end
  
  q:set(initQ)
  qOld:copy(q)

  dt = 0.02
  tStart, tEnd = 0.0, 0.2
  tcurr = tStart
  while tcurr<=tEnd do
    Lucee.setCurrTime(tcurr)
    status, suggestedDt = hyper.update(tcurr+dt)
    qOld:copy(q)
    tcurr = tcurr + dt
  end
#+END_EXAMPLE

* October 3rd

  Should setPtr method be in the FieldItr class instead? I.e. that
  would prevent using an iterator with the incorrect field.

  Should there be another class GridField? This would store the grid
  information inside it in addition to being a field. Perhaps call it
  a StructGridField to distinguish it from possible future
  UnStructGridField?

  Creates a StructGridField class for fields that live on structured
  grids. When its writeToFile() method is called it writes both the
  field data and the grid.

  Created a dummy method set() that will (when completed) initialize
  the field using a Lua function. [Later] DONE!!

  A problem: what happens when a Lucee object goes out of scope in Lua
  and gets garbage collected, while another Lucee object still has a
  reference to it? Potential solution: reference count each object?
  Can this be done transparently without changing any Lucee classes?

  Another problem: should time be a global in a Lucee simulation? Most
  likely not.

* October 2nd

  Now completed the creation of FieldPtr and ConstFieldPtr from
  std::vector.

  Need to now allow direct creation of DataStruct without the
  intervention of factories. DONE!

  There is a significant problem with type-saftey for objects created
  in Lua and accessed in Lucee. The issue is that Lua stores the
  object as a void* which means that all type information is lost!
  Although Lua suggests to use the luaL_checkudata method, the problem
  with this in Lucee is a confusion between base class and derived
  class names. I.e. we wish to access base class pointers even when
  the Lua object is a derived object.
  
  One solution is to add *two* metatables: one named after the base
  class and the other named after the derived class. Then, the access
  method should first check for the derived class metatable and then
  the base class metatable. If neither are found it should throw an
  error. [Does this not mean there should only be a derived class
  metatable? Perhaps something better is needed.]

  Added a method to write Field. Need to improve this by putting this
  in Field class and (a) writing the grid in the same h5 file and (b)
  not writing the ghost cells.

* October 1st

  I have written code to convert FieldPtr and ConstFieldPtr to T* and
  const T* respectively. This has two issues: loss of information
  (length is lost) and access to the raw data pointer.

  Perhaps one idea would be to introduce new classes (ConstVecWrap,
  VecWrap) that stores the pointer and the length and that can be
  constructed from FieldPtr and ConstFieldPtr, in addition to a
  std::vector<>. Then, basic functions like flux calculators can have
  signature

#+BEGIN_EXAMPLE
  void flux(ConstVecWrap q, VecWrap flx);
#+END_EXAMPLE 

  Which can be used as
#+BEGIN_EXAMPLE
  std::vector<double> q, flx;
  // set q
  q[0] = 0.0; q[1] = 1.0;
  flux(q, flx);
#+END_EXAMPLE

  This would mean that the Wrap objects must be passed as values as
  references can not be created to temporary.

  WAIT: This is exactly what a FieldPtr is!! So just extend it to
  initialize in addition from std::vector<>. DONE!

* September 30th

  Added more methods to StructuredGridBase class for access from
  Lua. This is an easy but tedious job. However, the basic code is now
  in place. Some objects like Region etc will need to be put into a
  global module (like Lucee.Region {}) so they become available from
  Lua. This can be done later.

  Added getObject() method to LuaTable class. This allows fetching
  reference to Lucee objects stored in Lua tables.

  Made SolverIfc class available from Lua scripts. Now RTE solver
  works from the script. The advance() method needs to be called
  explicitly.

  Removed builData() and buildAlgorithms() methods from SolverIfc.

* September 29th

  The factory methods need to be removed. This will eliminate the
  confusion of registering a factory instead of the actual object
  itself.

  [Later] Removed registration of factory for Grid. To do this I
  simply call the grid factory from the grid class and use the
  assignment operator to construct the object.

  Added a write method to GridIfc class to write grid to hdf5
  file. Seems to work just fine. At this point it seems all basic code
  for making Lucee objects callable from Lua is in place. Next to add
  methods to the LuaTable class to get userdata from the readInput()
  method.

* September 25th

  Most code to make Lucee objects usable from Lua scripts is now
  complete. Testing is needed. Also, need to figure out how to fetch a
  user-data object from a table (i.e. LuaTable object). All need for
  getNew() should now be over. Then, I can remove the ObjCreator class
  from the system and cleanup.

  [Later] There is a problem with the meta-table name embedded in each
  object: i.e. the meta-table name is constructured using the typid of
  the derived class but often the PointerHolder::checkUserType()
  method is called with the base class type. Hence, there is a
  mis-match of typeid() and Lua refuses to run the code. For now, I
  have switched out the luaL_checkudata() method for the
  lua_touserdata() method. Perhaps dynamic casting is needed? [Oct 2:
  Dynamic casts will not work as the basic object is a void* and hence
  C++ has no way of determining the object type]

  One other major problem is the existence of the Factories: when a
  Lua object will be created, it will return a pointer to the factory
  and not the actual object itself. This means the calls are made to
  the factory. This needs to be fixed ASAP.

  Also, writing the Lua callable methods will become rather
  tedious. Perhaps I need to add some helper classes to make this
  easier?

  [Later] The solution to the Factory created objects problem is to
  have two different methods that make the Lua object from C++ code:
  the first applies to classes that support readInput() directly. The
  second applies to classes that are created from a Factory. The
  choice between these methods can be made using two classes, one
  speclized to any T and the other to GenericFactory<T>.

  Also, the method appendLuaCallableMethods() from the derived Factory
  class will need to call the constructed object's
  appendLuaCallableMethods().

* September 23rd

  One way to automatically run the top-level simulation (if it exists)
  is to get the simulation object from C++, check if it really is a
  derived class of SolverIfc, check if it has already been run, and if
  not, run it.

* September 21st

  Just some notes to keep track of things. First, documentation needs
  to be started *now* to ensure it does not get too late to
  document. Need to update the doxygen comments to add more details.

* September 13th

  The LuaModule class needs to be modified to have a map:

#+BEGIN_EXAMPLE
  std::map<std::string, std::vector<luaL_Reg> > refFuncs;
#+END_EXAMPLE 

  or a more complex data-structure. The key could be the derived class
  Id and the vector could be the list of functions to register. The
  derived class should add all the methods it needs to this list.

  When the ObjCreator class moduleRegister() method is called it
  should add, in addition to the methods already added, the base class
  exposed methods and register all these methods. It should create a
  unique meta-table per derived class in so these methods become
  available in a object oriented manner.

  The main method to create the derived class itself should be as it
  is now: i.e. the module name should be the base class ID while the
  creation method name should be derived class ID.

  This will impose a requirement on all Lua callable class to provide
  a static method names appendLuaCallableMethods() to the supplied
  list.

* September 12th

  Figured out how to wrap C++ objects using the current Lucee
  system. Essentially just small modifications to the ObjCreator and
  ObjRegistry classes was needed. This work is in a branch

  https://lucee.googlecode.com/svn/branches/lua-obj

  At this point I have two tasks (a) create two new classes
  corresponding to ObjCreator and ObjRegistry to make Lua objects from
  Lucee objects (I could also simply modify the existing two classes)
  (b) create some means of allowing both base classes and derived
  classes to register methods to operate on the Lua objects.

  The latter task seems much harder to handle in a uniform manner. One
  obvious way to do this would be expect static methods in derived and
  base classes that are always called when the registration
  happens. Of course, this means that these methods must always be
  provided for the system to compile. Even after this is resolved, I
  still need to think of how the call will actually occur. The
  simplest, but least elegant way would be for each class to provide a
  static wrapper method that gets called from Lua. Then, the class
  would do a cast and make the call. Perhaps there is no other way to
  do this.

  However, once this is done, Lucee will have a very powerful manner
  of working. Objects could be created, queried for debugging and
  complete simulations written using Lua.

  Some notes on how to get this to work:

  - Need to rename the ObjCreator class to something more
    meaningful. I.e. as this class adds the Lua call-backs and does
    not really "create" anything.

  - The getNew() method from the ObjCreator can go away as it no
    longer will be needed.

  - The name of the metatable must be combination of the base-class ID
    and the derived class ID. How to do this? This can be done by
    extending the LuaModule class. In this, add the derived class ID
    (store in a vector of strings) and a map of derived class ID to
    callable methods. Then, in the ObjCreator's registerModule method
    we can loop over this and register stuff. (Will this really work?)

* September 10th

  Wrapping a C struct in Lua is very easy. There could still be a
  problem with wrapping C++ classes, though. The issue is that at
  first sight it seems impossible to call the default ctor of the
  class while creating it. Need to figure this out.

  However, once done, getting direct access to Lucee object in Lua
  should be relatively easy task. The main thing is to make the object
  contruction a two-step process: in the first, we register the object
  as usual. In the second we add a method to Lua to call the getNew()
  method. This method will get called, the object will be passed the
  table to construct itself and the resulting data returned. Will need
  to be careful with resource handling.

  A global singleton object holding pointers to all DataStructs,
  Updaters, Grids etc will need to be made. This will allow the C++
  code to access these objects so as to use them when needed.

* September 8th

  After a long time I am getting back to Lucee. I wish to complete the
  system at least to a point where I can solve 1D hyperbolic
  equations. This should be in preparation for the PPPL interview at
  which I would like to present results (if possible) only from Lucee.

  A better way needs to be found than the "table-driven" approach. It
  will be a radical departure from both Facets and Warpx. One option
  would be to have a file like
#+BEGIN_EXAMPLE
  grid = Grid.RectCart1D {
    cells = {10},
    lower = {0.0},
    upper = {1.0},
  }

  q1 = DataStruct.Field1D {
    onGrid = grid,
    numComponents = 5,
    ghost = {1, 2},
  }

  initField = Updater.TXYZFieldSetter2D {
    func = Function.LuaTXYZ {
    numOut = 5,
    f = function (t, x, y, z)
    return 1, 2, 3, 4, 5
    end,
  }

  initField.update(0.0, outVars = {q1})
  q1.sync()
  q1.dump("output.h5")
#+END_EXAMPLE

  This may be a radical change in the way Lucee works, but perhaps
  easier than I think.

* July 9th

  Added TXYZFieldSetter updater. Tested from code. This updater sets
  the supplied array using the provided function.

  Also ensured that updaters are now recognized from input files.

* July 8th

  Added LinCombiner updater. Tested from code. From input file this
  should look like, for example
#+BEGIN_EXAMPLE
  grid = Grid.RectCartGrid2D {
    cells = {10, 20},
    lower = {0.0, 0.0},
    upper = {1.0, 1.0},
  },

  combo = Updater.LinCombiner2D {
    onGrid = "grid",
    coeffs = {0.5, 0.5},
  }
#+END_EXAMPLE

* July 3rd
  
  The next step is to add a Stepper base class. This should run
  specified updater using a time-stepping mode. The stepping mode
  should be provided by derived classes. For example: ConstantDt class
  should provide a constant time-stepping mode where the dt is
  specified.

* July 2nd

  (A few days) No work for a while.

  Added UpdaterIfc class to represent updaters in Lucee. Initially
  these were derived from SolverIfc but had to break this up and make
  UpdaterIfc its own base class.

  One key objective was to allow use of updaters directly from code
  rather than just input files. This was achieved by letting users
  create an updater in code, set the inp/out data structures, and call
  the update(t) method.

  Added FunctionIfc class. This allows the creation of function
  objects that provide a eval() method:
#+BEGIN_EXAMPLE
    std::vector<double> eval(const std::vector<double>& inp);
#+END_EXAMPLE
  The size of input and out vectors can be specified as ctor
  parameters. 

  Redid the LuaFunction class: renamed it LuaTXYZFunction and it now
  derives from FunctionIfc. The LuaTable class had to be expanded to
  allow for getting access to references to Lua functions. This allows
  creation of LuaTXYZFunction from input file blocks.

* June 17th

  (A few days). Now have Fields initialized from input files. Also
  added a LuaFunction class that allows wrapping a Lua function in
  C++.

  The LuaTable class had a major bug in which the Lua stack size kept
  growing. This caused a segfault on my new Mac. Wrote a set of macros
  to track stack size. Now the stack is exactly balanced in each call.

  One thing that Lucee needs is a general set of vector operators:
  div, grad and curl. These operators should work on body fitted grids
  and should preserve the discrete vector calculus identities. One way
  to do this is to implement the Support Operator Method (SOM) for the
  discrete vector calculus operators. This would allow a combination
  of these operators to construct, for example, a Navier-Stokes
  solver.

* June 5/6th

  Completed reading of grids from input files and writing them out to
  HDF5.

  Major work to create typeMap in the LuaTable class. This allows the
  implementation of the getNamesOfType() method needed in
  SolverAssembly.
  
* June 4th
  
  Added GridBase class, derived StructuredGridBase from it and created
  a "Grid" module and registered it into Lucee.

* June 1st

  Completed BodyFittedGridBase and RectCartGrid classes. Tested the
  methods. Also added default ctor in Vec3.

  Why not use Vec3 for coordinates and vectors? The answer is that
  fixed sized vectors of size 3 are simpler, and probably much faster.

* May 28th

  - Fixed getSubCompView with ghost indices.
  - Seems like that for getSubCompView() should really have its
    component indices always starting with index 0. (Now fixed)

* May 27th

  Added ghost indices to fields. A lot of work to fix. Still does not
  work with slicing and sub-component views.

* May 26th

  - Created a Vec3 class to store vectors in 3D space. In preparation
    for adding a body-fitted grid class.

  - Started on BodyFittedGrid. The idea is to have a base class called
    BodyFittedGridBase from which BodyFittedGrid and CartGrid will be
    derived.

* May 25th

  Back to working on Lucee after a long while. Added a SolverAssembly
  class that will serve as a general purpose solver to assemble a
  simulation using grids, data and updaters.

  Need to figure out a way to avoid specifying dimensions in the input
  file. Everything can be determined from the dimension of the grid.

  Example::
#+BEGIN_EXAMPLE
    simulation = Solver.Assembly {
      domain = Grid.CartGrid {
        lower = {0.0, 0.0},
	upper = {1.0, 2.0},
	cells = {10, 20},
      },

      q = DataStruct.Field { 
        onGrid = domain,	
	numComponents = 5,
	ghost = {1, 1},
      },

      qOld = DataStruct.Field { 
        onGrid = domain, 
	numComponents = 5
      },

      qMom = DataStructAlias.Field {
        target = q,
	componentRange = {1, 4},
      },

      init = Updater.InitField {
        onGrid = domain,
      },

      stepper = Stepper.ConstantDt {
        dt = 1.5e-3,
	initialize = {initQStep, initiQoldStep},

	initQStep = Step {
	  updater = init,
	  out = {q}
	},
	initQoldStep = Step {
	  updater = init,
	  out = {q}
	},

      },
    }
#+END_EXAMPLE

* April 2nd - 6th

  No work on Lucee. Need to get back on this and bring the RTE solver
  to a completion.

* April 1st

  Trying to figure out particular solutions at dummy nodes. Seems like
  a real mess.

* March 31th

  Started work on dummy-node inclusion. Not working or complete
  yet. However basic ideas are clear.

* March 26th, 27th, 28th, 29th, 30th

  No work on Lucee.

* March 25th

  - Added cases 4 and 5 to verification studies. Setting
    varpi=1.0-1e-8 works well for cases when varpi=1.0. All decimal
    places for irradiances are computed correctly for irradiances.

* March 24th.

  No work.

* March 23rd

  - Now writing out irradiances. Tested irradiance E_0 with Siewert
    benchmark paper. Are exactly correct to all significant digits.
  - Next need to impliment dummy-node-inclusion method to get
    radiances at ordinates with zero weight.

* March 22nd

  - Added code to compute irradiances. Not tested and irradiances not
    yet written to file.
  - Added innerProduct() method to Vector class. NOT TESTED. Too tired
    to do this tonight but must do this.

* March 21st

  - Fixed a bug in hasStrVec() and hasNumVec() methods of LuaTable
    class. Not enough tests or else this would be caught earlier.
  - Added basic code to compute irradiances. Not complete yet.

* March 20th

  - Added duplicate() method to Array class.
  - Added method to write an array to HDF5 file. One needs to be a bit
    careful here as HDF5 expects data in row-major order while the
    default array layout is column major order.
  - Now writing out the radiance data as a numMode x N array rather
    than a separate array per mode.

* March 19th

  - Added code to compute half-space solution. Not tested.
  - Thought of using dummy node inclusion method as an interpolation
    technique for the RTE. Seems a better technique than the
    source-function integration method of Siwert.

* March 18

  - Now writing out RteHomogeneousSlab data as HDF5 files.
  - Started on benchmarking exercise with Garcia and Siewert paper.

* March 17

  - Debugged RteHomogeneousSlab. It now works.
  - Added HDF5 I/O classes to Lucee. Do not work for reading Vec
    attributes.

* March 15, 16

  - Now RteHomogeneousSlab solver basic algorithm is complete. Data
    yet to be written out. Now sure if to just do it in HDF5 or do
    some intermediate step before that.
  - Still need to figure out how to compute the irradiances.

* March 14
  
  - Added getView() method to matrix class.
  - Lot more work on RTE slab solver. Now close to being done.

* March 12, 13th

  - Added a document RteHomogeneousSlab.tex that describes the
    algorithm step by step.
  - Added scaleRows() and scaleCols() methods to the Matrix class.
  - More work on RTE solver.

* March 11th

  - Added phase function classes: HG phase function and phase function
    based on expansion coefficients.

* March 10th

  - Added LcMathLib file with math functions. Added gauleg() method.
  - Removed FcSimulation files. Now main() directly creates the
    SolverIfc class and drives.
  - Now have GSL properly linked. Some more familiarity with cmake is
    needed to get this figured out properly.

* March 9th

  - Added basic methods in LuaTable. Tested these. Next to implement
    the vector forms of these methods. Also, need to be careful about
    not polluting the stack.
  - All methos in LuaTable now implemented. Need to think about how to
    get and evaluate functions in Lua.
  - Module registration system needed re-work. Now seems to work.

* March 8th

  - Figured out way to use Lua tables. The basic idea it to use the
    luaL_ref() method to get a reference to the internal Lua table
    object. This can then be used to implement a persistent table
    access class.
  - Added a class LcLuaTable to represent tables. Not completed.

* March 5th, 6th and 7th

  No work on Lucee

* March 4th

  - Added ObjRegistry and ObjCreator classes. These were simply copied
    over from a old Lucee tag.

* March 3rd 2010

  - More playing around with Lua and object registration/creation
    process. Now figured out how to get global values and from tables,
    add new C call-back methods and register new modules.
  - Added lucee executable and command-line parsing, Simulation class.

* March 2nd 2010

  - Made notes on ideas for solvers Lucee. Added a class SolverIfc
    that defines the basic interface supported by all Lucee
    solvers. This will evolve as features are added, in particular
    when going parallel.
  - Starting to get better hold of reading table data out of LUA. Made
    LUA not use dynamic libraries.

* March 1st 2010

  - Fixed the getSubCompView() method. The solution is to get rid of
    the getLowIndex() method and use getIndex() method with 0 as the
    final index. This now allows selection of a range of components in
    a field to create a new field.
  - Renamed getGenIndex() -> genIndex().
  - Completed the solve() method in LcLinAlgebra. Unlike other
    linear-algebra methods, this one modifies the input matrix and
    also expects the matrices to be contiguous.

* Feb 28th 2010

  - Now getView() method works in LcField. The selection of
    sub-components of the field object seems rather tricky.
  - Discovered problem: when chaging start index both ai[0] and
    start[] are modified such that the modfied and new indexer return
    the same linear index. That is not what we want in selecting the
    sub-components. Instead, we want to just change ai[0] by sc so
    that the correct reference to the sc component is returned on
    passing 0 in the sub-comp-view field. Not yet fixed.

* Feb 27th 2010

  - Starting to add ability to find external libraries. First one: GSL
    for RTE work.

* Feb 26th 2010

  - Added getRow() and getCol() methods to Matrix class. Also added
    the ability to create Vector object from a Array<1, T>
    object. This allows the getRow() and getCol() methods to return
    Vector objects.

* Feb 25th 2010

  - To support deflating of Array the INDEXER template parameter had
    to be made a class template. Now, the Array declaration looks
    mighty ugly:
#+BEGIN_EXAMPLE
    template <unsigned NDIM, typename T, template <unsigned> class INDEXER  = Lucee::RowMajorIndexer>
    class Array;
#+END_EXAMPLE
    Further, Array<NDIM> class needs to friend itself to access private
    stuff from Array<RDIM>, where NDIM != RDIM. This horror looks
    like:
#+BEGIN_EXAMPLE
    template <unsigned RDIM, typename TT, template <unsigned> class IINDEXER> friend class Array;
#+END_EXAMPLE
  - Added deflate() methods to both indexer classes and to the array
    class. Seems to work just fine.
  - Derived classes of Array will need to provide their own deflate
    methods. In particular, Matrix class should support getting a row
    or a column. What should Field do?

* Feb 24th 2010

  - Completed Row and Col major sequencers.
  - Added a typedef to Row and Col indexers to allow creation of
    proper sequencers. This allows arrays and derived classes to use
    the correct indexer/sequencer pair.

* Feb 23rd 2010

  - Started work on row-major sequencers. Not complete yet.
  - Indexers may need to return associated sequencers.

* Feb 22nd 2010

  - Discovered a bug in indexers. It seems indexer hierachy needs to
    be rethought. The basic indexer class (common to linear indexing
    mechanisms) needs to be abstracted out into a base class. Then,
    the row and column major indexers will inhert from this base class
    and provide the coefficients in the linear mapping. It is not so
    clear what the system should be for non-linear mapping.
  - Completely redid the indexing system. Introduced a LinIndexer
    class from which the RowMajor and ColMajor indexer classes
    derive. Now should allow for slicing and deflating of arrays.

* Feb 21st 2010

  - Hooked in ctests into Lucee. Now one can run all the tests with
    one commmand in the top-level build directory, either 'ctest' or
    'make tests'.
  - Finished FieldItr class. This allows the following:
#+BEGIN_EXAMPLE
    int lo[2], up[2];
    Lucee::Box<2, int> rgn(lo, up);
    Lucee::Field<2, double> elcFld(rgn, 3);

    Lucee::FieldPtr<2> ptr = eclFld.createPtr();
    elcFld.setPtr(ptr, 5, 5);
    
    ptr[0] = 1.0;
    ptr[1] = 2.0;
    ptr[2] = 3.0;
#+END_EXAMPLE
    I.e, using FieldPtr one can access/modify the elements at a
    location in the field.
  - Finished ConstFieldPtr class. Same semantics as FieldPtr except
    that is allows pointing to constant Field objects.
  - Finished the getSlice() method in Array object. How do slices of
    derived classes work? Probably need a covariante return
    thunk. Also, this brought up the issue of being able to assign all
    the elements of a sliced-array.
