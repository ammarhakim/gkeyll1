\documentclass[11pt, reqno]{amsart}
%% AMS packages and font files
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[dvips]{graphicx}
\usepackage[usenames,dvipsnames]{color}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{algorithm}
\usepackage{algorithmic}
% \pagestyle{fancyplain}

\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}

%% Set page size properly
\oddsidemargin  0.0in
\evensidemargin 0.0in
\textwidth      6.5in
\textheight     9.0in
\headheight     1.0in
%\headsep        0.0in
\leftmargin      1.0in
\rightmargin      1.0in
\topmargin      -.75in

%% Autoscaled figures
\newcommand{\incfig}{\centering\includegraphics}
\setkeys{Gin}{width=0.9\linewidth,keepaspectratio}

%% Commonly used macros
\newcommand{\eqr}[1]{Eq.\thinspace(#1)}
\newcommand{\pfrac}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\pfracc}[2]{\frac{\partial^2 #1}{\partial #2^2}}
\newcommand{\pfraca}[1]{\frac{\partial}{\partial #1}}
\newcommand{\pfracb}[2]{\partial #1/\partial #2}
\newcommand{\pfracbb}[2]{\partial^2 #1/\partial #2^2}
\newcommand{\spfrac}[2]{{\partial_{#1}} {#2}}
\newcommand{\mvec}[1]{\mathbf{#1}}
\newcommand{\gvec}[1]{\boldsymbol{#1}}
\newcommand{\script}[1]{\mathpzc{#1}}

\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}

\theoremstyle{definition}
\newtheorem{dfn}{Definition}

\title{Notation and algorithms for coupled simulations}%
\author{Ammar H. Hakim}%
\date{}

\begin{document}
% header text
\lhead{Tech-Note 1001}
\maketitle

\section{The statement of the coupled problem}

Consider the problem of performing multiphysics simulations of complex
systems by coupling existing solvers. The problem can be stated
schematically as solving a coupled system of equations
\begin{align}
  \pfrac{\mvec{U}_1}{t} &= \frac{1}{\varepsilon_1}
  \script{L}_1(\mvec{U}_1, \mvec{c}_2) \label{eq:sys_1} \\
  \pfrac{\mvec{U}_2}{t} &= \frac{1}{\varepsilon_2}
  \script{L}_2(\mvec{U}_2, \mvec{c}_1) \label{eq:sys_2}
\end{align}
where $\mvec{U}_1 \in \mathbb{R}^{m_1}$ and $\mvec{U}_2 \in
\mathbb{R}^{m_2}$ are unknowns, $\mvec{c}_1 \in \mathbb{R}^{n_1}$ and
$\mvec{c}_2 \in \mathbb{R}^{n_2}$ are ``coupling'' variables and
$\varepsilon_1$ and $\varepsilon_2$ are positive scalar parameters. In
general $n_1\le m_1$ and $n_2\le m_2$. The operators $\script{L}_1$
and $\script{L}_2$ represent the physics of the systems being coupled
and may contain spatial derivative terms. The parameters
$\varepsilon_1$ and $\varepsilon_2$ are introduced to study the effect
of different time scales on the coupling. For example, coupling of
physics that occurs on different time scales can be studied by picking
$\varepsilon_1 \ll \varepsilon_2$.

The coupling between \eqr{\ref{eq:sys_1}} and \eqr{\ref{eq:sys_2}} is
through the variables $\mvec{c}_1$ and $\mvec{c}_2$
\begin{align}
  \mvec{c}_1 &= \script{C}_1(\mvec{U}_1) \label{eq:cpl_1} \\
  \mvec{c}_2 &= \script{C}_2(\mvec{U}_2). \label{eq:cpl_2}
\end{align}
The coupled problem can now be stated as follow. Given initial
conditions $\mvec{U}_1(t=0)$ and $\mvec{U}_2(t=0)$ evolve the system
\eqr{\ref{eq:sys_1}} and \eqr{\ref{eq:sys_2}} subject to the coupling
condition \eqr{\ref{eq:cpl_1}} and \eqr{\ref{eq:cpl_2}}.

\section{Explicit and implicit coupling}

To solve the coupled problem we will use the following scheme
\begin{align}
  \mvec{U}_1^{n+1} &= \mvec{U}_1^{n} + \frac{\Delta t}{\varepsilon_1}
  \script{L}_1(\mvec{U}_1^{n+1}, \mvec{c}_2^{n+k}) \\
  \mvec{U}_2^{n+1} &= \mvec{U}_2^{n} + \frac{\Delta t}{\varepsilon_2}
  \script{L}_2(\mvec{U}_2^{n+1}, \mvec{c}_1^{n+k})
\end{align}
where
\begin{align}
  \mvec{c}_1^{n+k} &= \script{C}_1(\mvec{U}_1^{n+k}) \label{eq:n_cpl_1} \\
  \mvec{c}_2^{n+k} &= \script{C}_2(\mvec{U}_2^{n+k}) \label{eq:n_cpl_2}
\end{align}
where $0 \le k \le 1$ and $\mvec{U}_i^k \equiv
(1-k)\mvec{U}_i^n+k\mvec{U}_i^{n+1}$. The coupling is \emph{explicit}
if $k=0$ and \emph{implicit} if $k>0$, in particular, if $k=1$. Here,
we are assuming that each individual system can be solved with an
implicit algorithm with a backward Euler time-discretization.

\section{Coupling as a coupling-variable consistency}

We will assume that there are available solvers that given the
solution at some time $t_n$ are able to compute the solution at
$t_{n+1} = t_n+\Delta t$
\begin{align}
  \mvec{U}_1^{n+1} &= \script{H}_1(\mvec{U}_1^n; \mvec{c}_2) \label{eq:bb_1} \\
  \mvec{U}_2^{n+1} &= \script{H}_2(\mvec{U}_2^n; \mvec{c}_1) \label{eq:bb_2}
\end{align}
Note that the solvers $\script{H}_i$, $i=1,2$ are for the
\emph{uncoupled problem with given} $\mvec{c}_i$. We can regard these
as ``black box'' functions that evolve the individual physics in the
absence of the coupling.

We can further abstract out the individual solvers by using
\eqr{\ref{eq:bb_1}} and \eqr{\ref{eq:bb_2}} to eliminate $\mvec{U}_i^{n+1}$
in \eqr{\ref{eq:n_cpl_1}} and \eqr{\ref{eq:n_cpl_2}}. This gives the
system, for $k=1$,
\begin{align}
  \mvec{c}_1^{n+1} &= 
  \script{C}_1\left(\script{H}_1(\mvec{U}_1^n;
    \mvec{c}_2^{n+1})\right)
  \equiv \script{K}_1(\mvec{c}_2^{n+1})
  \\
  \mvec{c}_2^{n+1} &= 
  \script{C}_2\left(\script{H}_2(\mvec{U}_2^n;
    \mvec{c}_1^{n+1})\right)
  \equiv \script{K}_2(\mvec{c}_1^{n+1}).
\end{align}
We call a set of coupling variables \emph{consistent} if they satisfy
this system. Hence, we can now restate problem of coupling the
original system of equations as a \emph{consistency problem for the
  coupling variables}.

Note that it seems that the coupling problem has been \emph{reduced}
in size from solving a system of $m_1+n_1+m_2+n_2$ equations to
solving a \emph{smaller} system of $n_1+n_2$ equations for just the
coupling variables. This reduction in size of the problem is, however,
misleading, as the uncoupled solvers $\script{H}_i$ are still needed
to solve the ``reduced'' consistency problem.

\section{Coupling algorithms}

Each algorithm produces $\mvec{U}_i^{n+1}$ given $\mvec{U}_i^{n}$ and
the functions $\script{H}_i$, for $i=1,2$. The $\mvec{c}_i$ are
computed using \eqr{\ref{eq:cpl_1}} and \eqr{\ref{eq:cpl_2}} and
$\epsilon$ is a convergence parameter.

\subsection{The explicit algorithm}

To contrast with the implicit coupling algorithm we can first look at
the explicit coupling algorithm.
\begin{algorithm}
\caption{Explicit Coupling}
\begin{algorithmic}
%\STATE $\mvec{c}_1^n \leftarrow \script{C}_1(\mvec{U}_1^n)$
%\STATE $\mvec{c}_2^n \leftarrow \script{C}_2(\mvec{U}_2^n)$
\STATE $\mvec{U}_1^{n+1} \leftarrow \script{H}_1(\mvec{U}_1^n; \mvec{c}_2^n)$
\STATE $\mvec{U}_2^{n+1} \leftarrow \script{H}_2(\mvec{U}_2^n; \mvec{c}_1^n)$
\end{algorithmic}
\end{algorithm}
In the explicit algorithm we use the \emph{old} values of the solution
to compute the coupling variables and use these to advance the
solution to the new time.

\subsection{Picard iteration and its variants}

The simplest implicit algorithm is essentially a fixed-point iteration
or \emph{Picard iteration} scheme defined as follows.
\begin{algorithm}
\caption{Coupling with Picard Iteration}
\begin{algorithmic}
\STATE $\mvec{c}_1^0 \leftarrow \script{C}_1(\mvec{U}_1^n)$
\STATE $\mvec{c}_2^0 \leftarrow \script{C}_2(\mvec{U}_2^n)$
\WHILE{$|\mvec{c}_1^{m+1}-\mvec{c}_1^m| > \epsilon$ and $|\mvec{c}_2^{m+1}-\mvec{c}_2^m| > \epsilon$}
\STATE $\mvec{U}_1^{m+1} \leftarrow \script{H}_1(\mvec{U}_1^n; \mvec{c}_2^m)$
\STATE $\mvec{U}_2^{m+1} \leftarrow \script{H}_2(\mvec{U}_2^n; \mvec{c}_1^m)$
\STATE $m \leftarrow m+1$
\ENDWHILE
\end{algorithmic}
\end{algorithm}

Several variations on the Picard iteration can be imagined. For
example the following algorithm uses the updated solution to
$\mvec{U}_1$ to compute the solution $\mvec{U}_2$.
\begin{algorithm}
\caption{Modified Picard Iteration}
\begin{algorithmic}
\STATE $\mvec{c}_1^0 \leftarrow \script{C}_1(\mvec{U}_1^n)$
\STATE $\mvec{c}_2^0 \leftarrow \script{C}_2(\mvec{U}_2^n)$
\WHILE{$|\mvec{c}_1^{m+1}-\mvec{c}_1^m| > \epsilon$ and $|\mvec{c}_2^{m+1}-\mvec{c}_2^m| > \epsilon$}
\STATE $\mvec{U}_1^{m+1} \leftarrow \script{H}_1(\mvec{U}_1^n; \mvec{c}_2^m)$
\STATE $\mvec{U}_2^{m+1} \leftarrow \script{H}_2(\mvec{U}_2^n; \mvec{c}_1^{m+1})$
\STATE $m \leftarrow m+1$
\ENDWHILE
\end{algorithmic}
\end{algorithm}
The disadvantage of this modified algorithm is that it does not allow
concurrent evaluation of the functions $\script{H}_i$ as we need
$\mvec{U}_1^{m+1}$ before $\mvec{U}_2^{m+1}$ can be computed.

\end{document}

